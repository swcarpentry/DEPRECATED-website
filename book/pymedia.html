{% extends "_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Basic Programming With Python and Images" />
{% endblock file_metadata %}

{% block content %}

<p>
  Valerie Visual is studying how people visualize and recall color.
  For one of her experiments,
  she wants to cut a photograph of faces into rectangular pieces
  and time how long it takes subjects to reassemble those pieces
  after they have been recolored in different ways.
</p>

<p>
  If Valerie only wanted to use one or two images,
  the simplest way to create the puzzles she needs might be
  to use a tool like Photoshop.
  However,
  she wants to give each subject several dozen puzzles to solve
  (since each one typically only takes a few seconds to assemble).
  Since she doesn't want to spend hours cutting and coloring images,
  she wants to write a small program to do the job for her.
  To do that,
  she's going to have to learn how to program,
  and that's what the next couple of chapters are about.
</p>

<p>
  We will use a programming language called Python for our examples.
  Python is free,
  reasonably well documented,
  and widely used in science and engineering.
  Our main reason for choosing it,
  though,
  is that newcomers find it easier to read than most other languages.
  It also allows people to do useful things
  without having to master advanced concepts like object-oriented programming.
</p>

<p>
  Our programs will use a library for manipulating images
  that was specifically written for novices.
  Many of the things we will do in five or ten lines
  can actually be done in a single line by an experienced programmer,
  but since our goal is to show you how to write programs of your own,
  we will leave the training wheels on for now.
</p>

<section id="s:basic">

  <h2>Basic Operations</h2>

  <div class="understand" id="u:basic">
    <h3>Understand:</h3>
    <ul>
      <li>How to use the Python interpreter interactively.</li>
      <li>How to do basic arithmetic.</li>
      <li>How to assign values to variables.</li>
    </ul>
  </div>

  <p>
    The best way to learn how to program is to start programming,
    so let's run the Python interpreter
    and type in the following:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 1 + 1</span>
<span class="out">2</span>
</pre>

  <p class="continue">
    The <code>&gt;&gt;&gt;</code> <a href="glossary.html#prompt">prompt</a>
    is the interpreter's way of telling us that it's waiting for input,
    like the <code>$</code> prompt in <a href="shell.html">the shell</a>.
    When we enter 1+1,
    Python does the calculation we've asked for
    and prints the result.
  </p>

  <p>
    Now type this:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">x = 1+1</span>
</pre>

  <p class="continue">
    Python doesn't display anything this time
    (except another prompt).
    Instead,
    as <a href="#f:first_variable">Figure 1</a> shows,
    it creates a <a href="glossary.html#variable">variable</a> called <code>x</code>
    and assigns it the value 2.
    We can then get that variable's value simply by entering its name:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print x</span>
<span class="out">2</span>
</pre>

  <figure id="f:first_variable">
    <img src="img/python/first_variable.png" alt="Our First Variable" />
  </figure>

  <div class="box">

    <h3>Statements vs. Expressions</h3>

    <p>
      Python is a fairly relaxed language,
      but there are still some things it won't let us do.
      For example,
      this doesn't work:
    </p>

<pre>
print x = 1 + 2
<span class="err">SyntaxError: invalid syntax</span>
</pre>

    <p class="continue">
      The problem is that printing and assignment are both
      <a href="glossary.html#statement">statements</a>,
      and statements cannot be mixed together.
      1+2, on the other hand,
      is an <a href="glossary.html#expression">expression</a>&mdash;something
      that produces a new value&mdash;and expressions can be combined in many ways.
      Except for assignment,
      every statement in Python begins with a keyword like <code>print</code>,
      so it's usually easy to tell them apart.
    </p>

  </div>

  <p>
    We can now use that variable's value in calculations:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print x * 2</span>
4
</pre>

  <p class="continue">
    including ones that create more variables:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">y = x * 2</span>
&gt;&gt;&gt; <span class="in">print y</span>
<span class="out">4</span>
</pre>

  <p class="continue">
    We can change a variable's value
    by assigning something new to it:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">x = 10</span>
&gt;&gt;&gt; <span class="in">print x</span>
10
</pre>

  <p class="continue">
    As <a href="#f:assign_new_value">Figure XXX</a> shows,
    assigning something to <code>x</code> changes what it points to,
    but does not change anything else.
    In particular,
    <code>y</code> still has the value 4 after this assignment:
    it is not automatically updated when <code>x</code>'s value changes,
    as it would in a spreadsheet.
  </p>

  <figure id="f:assign_new_value">
    <img src="img/python/assign_new_value.png" alt="Assigning a New Value" />
  </figure>

  <p>
    Here's a more complex calculation:
  </p>

<pre src="src/python/fahrenheit_to_kelvin_unreadable.py">
&gt;&gt;&gt; <span class="in">x = 98.6</span>
&gt;&gt;&gt; <span class="in">y = (x - 32.0) * (5.0 / 9.0) + 273.15</span>
&gt;&gt;&gt; <span class="in">print y</span>
<span class="out">310.15</span>
</pre>

  <p class="continue">
    Its meaning becomes clearer if we rewrite it as:
  </p>

<pre src="src/python/fahrenheit_to_kelvin.py">
&gt;&gt;&gt; <span class="in">temp_fahr = 98.6</span>
&gt;&gt;&gt; <span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
&gt;&gt;&gt; <span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    The first line creates a new variable called <code>temp_fahr</code>
    (short for "temperature in Fahrenheit")
    and gives it the value 98.6
    (<a href="#f:first_memory_model">Figure XXX</a>).
    The second line creates another variable to hold the temperature in Kelvin
    (hence its name).
    It calculates a value for this variable
    that depends on the value of <code>temp_fahr</code>.
    The last line prints the result.
    The <a href="glossary.html#string">character string</a>
    (or just "string" for short)
    inside double quotes is printed as-is,
    followed by the value of <code>temp_kelvin</code>.
  </p>

  <figure id="f:first_memory_model">
    <img src="img/python/first_memory_model.png" alt="First Memory Model" />
  </figure>

  <p>
    Like every program,
    this one stores data and does calculations.
    We use variables to do the first,
    and write instructions that use those variables to do the second.
    And like every <em>good</em> program,
    this one is written with human beings in mind.
    Computers get faster every year,
    but our brains don't.
    As a result,
    the real bottleneck in scientific computing is usually not
    how fast the program runs,
    but how long it takes us to write it.
    This is why we use variable names like <code>temp_fahr</code> and <code>temp_kelvin</code>
    instead of <code>x</code> and <code>y</code>.
  </p>

  <div class="box">

    <h3>Creating Variables</h3>

    <p>
      Python creates a variable whenever a value is assigned to a name,
      but won't let us get the value of a variable that hasn't been assigned one.
      For example,
      if we try to do this:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">double_temp = temp_celsius * 2</span>
</pre>

    <p class="continue">
      then Python prints an error message:
    </p>

<pre>
<span class="err">Traceback (most recent call last):
  File "&lt;undefined-variable.py&gt;", line 1, in &lt;module&gt;
NameError: name 'temp_celsius' is not defined</span>
</pre>

    <p class="continue">
      We'll explain what "module" means <a href="funclib.html">later</a>.
      What's important now is that this strictness helps catch a lot of typing mistakes:
      if we mistakenly type <code>temp_far</code> instead of <code>temp_fahr</code>:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">temp_kelvin = (<span class="highlight">temp_far</span> - 32.0) * (5.0 / 9.0) + 273.15</span>
</pre>

    <p class="continue">
      then Python will tell us something's gone wrong.
      It can't help us if we type 3.20 instead of 32.0, though;
      if we want to catch that mistake,
      we'll actually have to <a href="quality.html">test our program</a>.
    </p>

  </div>

  <p>
    Readability is also why we put the temperature in Fahrenheit in a variable,
    then use that variable in line 2,
    rather than just putting 98.6 directly in the calculation.
    If we ever want to convert another temperature,
    it's easier to see and change the value on line 1
    than it would be to find it buried in the middle of a line of arithmetic.
  </p>

  <p>
    Finally,
    this first program also shows how arithmetic is done.
    '+' means addition,
    '*' means multiplication,
    and parentheses group things together,
    just as they do in pen-and-paper arithmetic.
    We have to use parentheses here because
    (also as in arithmetic)
    multiplication takes precedence over addition:
    the expression <code>2*3+5</code> means,
    "Multiply two by three, then add five,"
    rather than,
    "Add three and five, then multiple by two."
    If we want the latter,
    we have to write <code>2*(3+5)</code>.
  </p>

  <div class="box">

    <h3>Repeating Commands</h3>

    <p>
      Just as we could repeat previous commands in the shell
      by using the <a href="shell.html#a:repeat">up arrow</a>,
      so too can we repeat commands in the Python interpreter.
      And while the standard interpreter doesn't have an equivalent
      of the shell's <code>history</code> command,
      more advanced shells like IPython do
      (along with much more).
    </p>

  </div>

  <div class="keypoints" id="k:basic">
    <h3>Summary</h3>
    <ul>
      <li>Use '=' to assign a value to a variable.</li>
      <li>Assigning to one variable does not change the values associated with other variables.</li>
      <li>Use <code>print</code> to display values.</li>
      <li>Variables are created when values are assigned to them.</li>
      <li>Variables cannot be used until they have been created.</li>
      <li>Addition ('+'), subtraction ('-'), and multiplication ('*') work as usual in Python.</li>
      <li idea="perf">Use meaningful, descriptive names for variables.</li>
    </ul>
  </div>

</section>

<section id="s:types">

  <h2>Types</h2>

  <div class="understand" id="u:types">
    <h3>Understand:</h3>
    <ul>
      <li>What data types are.</li>
      <li>The differences between integers, floating-point numbers, and strings.</li>
      <li>How to call a function.</li>
      <li>Why computers shouldn't guess what people want.</li>
    </ul>
  </div>

  <p>
    Let's take another look at our program:
  </p>

<pre src="src/python/fahrenheit_to_kelvin.py">
&gt;&gt;&gt; <span class="in">temp_fahr = 98.6</span>
&gt;&gt;&gt; <span class="in">temp_kelvin = (temp_fahr - 32.0) * (5.0 / 9.0) + 273.15</span>
&gt;&gt;&gt; <span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 310.15</span>
</pre>

  <p>
    Why have we written 5.0/9.0 instead of 5/9?
    Let's see what happens if we take out the .0's:
  </p>

<pre src="src/python/fahrenheit_to_kelvin_int.py">
&gt;&gt;&gt; <span class="in">temp_fahr = 98.6</span>
&gt;&gt;&gt; <span class="highlight">temp_kelvin = (temp_fahr - 32) * (5 / 9) + 273.15</span>
&gt;&gt;&gt; <span class="in">print "body temperature in Kelvin:", temp_kelvin</span>
<span class="out">body temperature in Kelvin: 273.15</span>
</pre>

  <p>
    That's not right.
    To understand what's gone wrong,
    let's look at 5/9:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">5/9</span>
<span class="out">0</span>
</pre>

  <p>
    The problem is that integers and floating point numbers
    (or <a href="glossary.html#float">floats</a>)
    are different things to a computer.
    If a number doesn't have a decimal point,
    then Python stores its value as an integer (with no fractional part).
    When it divides one integer by another,
    it throws away the remainder.
    If a number contains a decimal point,
    though,
    Python stores it as a float.
    When it does division (or any other kind of arithmetic),
    the result is a float if either of the values involved is a float:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">10 / 3</span>
<span class="out">3</span>
&gt;&gt;&gt; <span class="in">10.0 / 3</span>
<span class="out">3.3333333333333335</span>
</pre>

  <p class="continue">
    This makes sense,
    but only if you understand how the chips inside computers work.
    Version 3 of Python changed the rules for division
    so that it returns fractional numbers whenever it needs to.
    However,
    we're using Python 2.7 in this course,
    so 10/3 is 3 until further notice.
  </p>

  <p>
    Every value in a program has a specific <a href="glossary.html#type">type</a>
    which determines how it behaves
    and what can be done to it.
    We can find out what type something is
    using a built-in <a href="glossary.html#function">function</a> called <code>type</code>:
  </p>


<pre>
&gt;&gt;&gt; <span class="in">type(12)</span>
<span class="out">&lt;type 'int&gt;</span>
&gt;&gt;&gt; <span class="in">type(12.0)</span>
<span class="out">&lt;type 'float&gt;</span>
</pre>

  <p>
    Integers and floating-point numbers are two common types;
    another is the character string.
    We can create one by putting characters inside either single or double quotes
    (as long as they match at the beginning and end):
  </p>

<pre src="src/python/simple_string.py">
&gt;&gt;&gt; <span class="in">name = "Alan Turing"</span>
&gt;&gt;&gt; <span class="in">born = 'June 23, 1912'</span>
&gt;&gt;&gt; <span class="in">print name, born</span>
<span class="out">Alan Turing June 23, 1912</span>
</pre>

  <p>
    We can also "add" strings:
  </p>

<pre src="src/python/simple_string.py">
&gt;&gt;&gt; <span class="in">full = name + " (" + born + ")"</span>
&gt;&gt;&gt; <span class="in">print full</span>
<span class="out">Alan Turing (June 23, 1912)</span>
</pre>

  <p>
    What we <em>can't</em> do is add numbers and strings:
  </p>

<pre src="src/python/add_numbers_strings.py">
&gt;&gt;&gt; <span class="in">print 2 + "three"</span>
<span class="err">Traceback (most recent call last):
  File "add-numbers-strings.py", line 1, in &lt;module&gt;
    print 2 + "three"
TypeError: unsupported operand type(s) for +: 'int' and 'str'</span>
</pre>

  <p>
    The string "2three" would be a reasonable result in this case,
    but it's not so clear what <code>2+"3"</code> should do:
    should it produce the integer 5 or the string <code>"23"</code>?
    Rather than guessing at the programmer's intentions,
    Python expects some guidance:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print 2 + int("3")</span>
<span class="out">5</span>
&gt;&gt;&gt; <span class="in">print str(2) + "3"</span>
<span class="out">23</span>
</pre>

  <p>
    <code>int</code> and <code>str</code> are two more built-in functions
    which convert values to particular types.
    We'll look at functions in much more detail
    in <a href="funclib.html">the next chapter</a>.
  </p>

  <div class="keypoints" id="k:types">
    <h3>Summary</h3>
    <ul>
      <li>The most commonly used data types in Python are integers (<code>int</code>), floating-point numbers (<code>float</code>), and strings (<code>str</code>).</li>
      <li>Strings can start and end with either single quote (') or double quote (&quot;).</li>
      <li>Division ('/') produces an <code>int</code> result when given <code>int</code> values: one or both arguments must be <code>float</code> to get a <code>float</code> result.</li>
      <li>"Adding" strings concatenates them, multiplying strings by numbers repeats them.</li>
      <li idea="meaning">Strings and numbers cannot be added because the behavior is ambiguous: convert one to the other type first.</li>
      <li>Variables do not have types, but values do.</li>
    </ul>
  </div>

</section>

<section id="s:openshow">

  <h2>Displaying Images</h2>

  <div class="understand" id="u:openshow">
    <h3>Understand:</h3>
    <ul>
      <li>How to open and display images.</li>
      <li>What a library is.</li>
      <li>Why programs are built out of libraries.</li>
      <li>What a method is and how to call one.</li>
    </ul>
  </div>

  <p>
    Now that we can do basic arithmetic,
    let's look at some images:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">from skimage import novice</span>
&gt;&gt;&gt; <span class="in">flower = novice.open('flower.jpg')</span>
&gt;&gt;&gt; <span class="in">flower.show()</span>
</pre>

  <p>
    This three-line program introduces one new idea per line.
    The first statement asks Python to find a library called <code>skimage</code>
    (the SciKit image processing library)
    and load something called <code>novice</code> from it.
    The second statement asks <code>novice</code> to open a file called <code>flower.jpg</code>;
    the result of that operation is assigned to a variable called <code>flower</code>.
    The final statement asks the thing <code>flower</code> now points at to display itself.
    If all has gone well,
    this should show a picture of the world's cutest child
    (<a href="#f:flower">Figure XXX</a>).
  </p>

  <figure id="f:flower">
    <img src="img/pymedia/flower.jpg" alt="The World's Cutest Child" />
  </figure>

  <p>
    A <a href="glossary.html#library">library</a>
    (or <a href="glossary.html#module">module</a>&mdash;for our purposes, the terms mean the same thing)
    is one of the most important ideas in all of programming.
    No language could possibly contain every single feature that everyone might ever want.
    Even if it did,
    people's needs evolve over time,
    so an "all inclusive" approach would mean constantly releasing new versions of the language.
    Instead,
    every programming language provides a way for people to define new tools themselves,
    and then load those tools into other programs.
    In this case,
    someone wrote an image processing library called <code>skimage</code>,
    and someone else (a graduate student named Mike Hansen)
    added a sub-library to it called <code>novice</code>
    to provide an easy-to-use interface for people who are just learning to program.
    When we write:
  </p>

<pre>
from skimage import novice
</pre>

  <p class="continue">
    we are asking Python to find the <code>skimage</code> library,
    search inside it for <code>novice</code>,
    and load that into memory for use.
  </p>

  <p>
    To get at the things <code>novice</code> contains,
    we then refer to them as <code>novice.<em>something</em></code>.
    This <a href="glossary.html#dotted-notation">dotted notation</a> was invented
    to deal with the fact that people often choose the same names for different things.
    For example,
    <code>skimage.novice</code>'s <code>open</code> looks for a file on disk and opens that,
    but another library called <code>web</code> might provide something called <code>open</code>
    that opened a connection to a web site.
    Using <code>thing.subthing.subsubthing</code> to name things
    is exactly like using the genus and species names to identify particular organisms.
  </p>

  <div class="box">

    <h3>There's More Than One Way to Name It</h3>

    <p>
      You may have noticed above that we referred to <code>novice</code> as <code>skimage.novice</code>.
      If we want to do this in our program,
      we could rewrite it as:
    </p>

<pre>
import skimage
flower = skimage.novice.open('flower.jpg')
flower.show()
</pre>

    <p class="continue">
      which performs exactly the same operations as the original.
      What we <em>can't</em> do is:
    </p>

<pre>
import skimage
flower = novice.open('flower.jpg')
</pre>

    <p class="continue">
      or:
    </p>

<pre>
from skimage import novice
flower = skimage.novice.open('flower.jpg')
</pre>

    <p class="continue">
      The first (<code>import skimage</code>) doesn't define anything in our program called <code>novice</code>;
      it only defines <code>skimage</code>.
      The second does the reverse:
      it defines <code>novice</code> <em>without</em> defining <code>skimage</code>.
    </p>

    <p>
      And yes,
      we could do this:
    </p>

<pre>
from skimage.novice import open
flower = open('flower.jpg')
</pre>

    <p class="continue">
      but it would be a very bad idea.
      Python actually has a built-in function called <code>open</code>
      that opens arbitrary files so that the bytes in them can be read.
      If we run the code shown immediately above,
      that built-in function will be replaced by
      <code>skimage.novice</code>'s <code>open</code>,
      which will probably break most programs
      (since most files aren't actually images).
    </p>

  </div>

  <p>
    With that out of the way,
    the second statement in:
  </p>

<pre>
from skimage import novice
<span class="highlight">flower = novice.open('flower.jpg')</span>
flower.show()
</pre>

  <p class="continue">
    should be pretty easy to understand.
    It's a function call:
    it just happens that the function being called is contained in the <code>novice</code> library.
    Similarly,
    the expression <code>flower.show()</code> is another call
    that asks whatever the variable <code>flower</code> points at
    to call the <code>show</code> function it contains.
  </p>

  <p>
    Another way to think about this program is shown in <a href="#f:memory_model_image_display">Figure XXX</a>.
    After the first statement,
    Python has created a variable called <code>novice</code>
    that refers to <code>skimage</code>'s <code>novice</code> module.
    After the second statement,
    that module has loaded bytes from an image file on disk into memory,
    wrapped an object around them,
    and creatd a variable called <code>flower</code> to refer to that object.
  </p>

  <figure id="f:memory_model_image_display">
    <img src="img/pymedia/memory_model_image_display.jpg" alt="Memory Model of Image Display Program" />
  </figure>

  <div class="keypoints" id="k:openshow">
    <h3>Summary</h3>
    <ul>
      <li class="fixme">Write summary</li>
      <li class="fixme">Explain scope of imports: program session</li>
    </ul>
  </div>

</section>

<section id="s:program">

  <h2>Creating Programs</h2>

  <div class="understand" id="u:program">
    <h3>Understand:</h3>
    <ul>
      <li>How to create and run programs.</li>
    </ul>
  </div>

  <p>
    Typing in commands over and over again is tedious and error-prone.
    Just as we saved shell commands in <a href="shell.html#s:scripts">shell scripts</a>,
    we can save Python commands in files
    and then have the Python interpreter run those.
    Using your favorite text editor,
    put the following three lines into a plain text file:
  </p>

<pre src="src/python/greeting.py">
left = "hello"
right = "there"
print left, right
</pre>

  <p class="continue">
    and then save it as <code>greeting.py</code>.
    (By convention,
    Python files end in '.py'
    rather than '.txt'.)
    To run it from the shell,
    type:
  </p>

<pre>
$ <span class="in">python greeting.py</span>
<span class="out">hello there</span>
</pre>

  <p>
    Of course,
    we can do this with our image display program as well:
  </p>

<pre>
import skimage
flower = skimage.novice.open('flower.jpg')
flower.show()
</pre>

  <p>
    When we save this as <code>showflower.py</code>,
    and run it as:
  </p>

<pre>
$ <span class="in">python showflower.py</span>
</pre>

  <p class="continue">
    it displays our picture.
    <span class="fixme">explain how to kill it</span>
  </p>

  <p>
    When the Python interpreter executes a file,
    it runs the commands in that file
    just as if they had been typed in interactively.
    It doesn't wait until the whole file has been read
    to start executing;
    instead,
    as the example below shows,
    it runs each command as soon as it can:
  </p>

    <!-- JK: I think what was intended here was for the first 3 lines to 
         replace the existing 3 lines in greeting.py, then 'python greeting.py' 
         was to be run from the shell? If so, having the first 3 new lines in a 
         separate blue box might be more clear. Also, the text below currently
         references a.py. -->

<pre src="src/python/executing_file.py">
print "before"
1/0
print "after"
<span class="out">before</span>
<span class="err">Traceback (most recent call last):
  File "a.py", line 2, in &lt;module&gt;
    1/0
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <p class="continue">
    Note that this can lead to some confusing output.
    For example,
    if we change the example above to:
  </p>

<pre>
print "before", 1/0, "after"
</pre>

  <p class="continue">
    then the output is:
  </p>

<pre><span class="out">before</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ZeroDivisionError: integer division or modulo by zero</span>
</pre>

  <div class="keypoints" id="k:program">
    <h3>Summary</h3>
    <ul>
      <li>Store programs in files whose names end in <code>.py</code> and run them with <code>python <em>name.py</em></code>.</li>
    </ul>
  </div>

</section>

<section id="s:properties">

  <h2>Image Properties</h2>

  <div class="understand" id="u:properties">
    <h3>Understand:</h3>
    <ul>
      <li>How to inspect and modify the properties of images.</li>
      <li>How to save images to files.</li>
    </ul>
  </div>

  <p>
    Let's take another look at the world's cutest child:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">from skimage import novice</span>
&gt;&gt;&gt; <span class="in">flower = novice.open('flower.jpg')</span>
&gt;&gt;&gt; <span class="in">flower.show()</span>
</pre>

  <p class="continue">
    What else can we do besides display this image?
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print flower.format</span>
<span class="out">JPEG</span>
&gt;&gt;&gt; <span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/flower.jpg</span>
&gt;&gt;&gt; <span class="in">print flower.height</span>
<span class="out">180</span>
&gt;&gt;&gt; <span class="in">print flower.width</span>
<span class="out">240</span>
</pre>

  <p>
    As this example shows,
    a picture object has <a href="glossary.html#property">properties</a>:
    its format (JPEG, PNG, and so on),
    the path to the file it was loaded from,
    and its height and width in pixels.
    Some of these are unchangeable,
    so that we can confuse our program
    by fooling it into thinking that a JPEG image is actually stored as a PNG,
    or that it was loaded from a different file than it actually was:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.format = 'PNG'</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: can't set attribute</span>
&gt;&gt;&gt; <span class="in">flower.path = '/profiles/alan-turing.jpg'</span>
<span class="err">Traceback (most recent call last):
  File "&lt;stdin&gt;", line 2, in &lt;module&gt;
AttributeError: can't set attribute</span>
</pre>

  <p>
    Others,
    however,
    are changeable.
    For example,
    we can squish the image by altering its height
    (<a href="#f:flower_squished">Figure XXX</a>).
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.height = 90</span>
&gt;&gt;&gt; <span class="in">flower.show()</span>
</pre>

  <figure id="f:flower_squished">
    <img src="img/pymedia/flower_squished.jpg" alt="Squishing a Picture" />
  </figure>

  <p>
    We can now save this picture to a new file if we want:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.save('squished.jpg')</span>
</pre>

  <p>
    When we do this,
    the object's <code>path</code> property is automatically updated:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/squished.jpg</span>
</pre>

  <p>
    And if we want to change its format,
    we can do that by saving it to a file with the appropriate suffix:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">flower.save('squished.<span class="highlight">png</span>')</span>
&gt;&gt;&gt; <span class="in">print flower.path</span>
<span class="out">/home/gvwilson/examples/squished.png</span>
</pre>

  <p>
    Now,
    suppose we want to create a thumbnail of a picture to put on a web page.
    We want the thumbnail to be exactly 30 pixels wide to fit into a table,
    and we want its height scaled proportionally.
    Here's what we could do:
  </p>

<pre>
from skimage import novice
picture = novice.open('mac.jpg')
new_height = picture.height * 30 / picture.width
picture.height = new_height
picture.width = 30
picture.save('thumb-mac.jpg')
</pre>

</section>

<section id="s:color">

  <h2>Colors</h2>

  <div class="understand" id="u:color">
    <h3>Understand:</h3>
    <ul>
      <li>How computers represent colors.</li>
      <li>How to create images from scratch.</li>
      <li>How to change the color of every pixel in an image.</li>
    </ul>
  </div>

  <p>
    Before we go any further,
    we need to talk about how computers represent colors.
    The most common scheme,
    called "RGB",
    stores red, green, and blue values for each pixel in an image.
    This is an additive color model:
    the color we see is the sum of the individual color values,
    each of which can range between 0 and 255.
    (Why 255?
    Because computer memory is organized into 8-bit bytes,
    and 255 (11111111 in base 2) is the largest integer that can be represented in one byte.)
  </p>

  <p>
    In RGB,
    black is (0, 0, 0), i.e., nothing of any color.
    White is the maximum value of all three colors, or (255, 255, 255).
    We can think of this color model is as a cube
    (<a href="#f:color_cube">Figure XXX</a>).:
    the three axes represent the primary colors,
    while secondary colors are combinations of maximum values,
    and each actual color is a coordinate in this cube.
  </p>

  <figure id="f:color_cube">
    <img src="img/pymedia/color_cube.png" alt="A Color Cube" />
  </figure>

  <p>
    Let's have a look at how the three primary colors actually appear:
  </p>

<pre>
from skimage import novice
all_red = novice.new((200, 200), (255, 0, 0))
all_red.show()
all_green = novice.new((200, 200), (0, 255, 0))
all_green.show()
all_blue = novice.new((200, 200), (0, 0, 255))
all_blue.show()
</pre>

  <figure id="f:primary_colors">
    <img src="img/pymedia/primary_colors.png" alt="Primary Colors" />
  </figure>

  <p>
    This program produces the three images shown in <a href="#f:primary_colors">Figure XXX</a> in turn.
    The most important thing about it, though,
    is actually where the parentheses are.
    Just as in math,
    programs often use parentheses to group values together.
    Here,
    we are using them to group (200, 200) together as the size of the image in pixels,
    and (255, 0, 0) together as an RGB color value.
    The designer of this library <em>could</em> have let us pass these values without the grouping,
    as in:
  </p>

<pre>
novice.new(200, 200, 255, 0, 0)
</pre>

  <p class="continue">
    but as the number of values grows,
    it quickly becomes difficult to keep track of which ones belong together.
    A group of parenthesized values is called <a href="glossary.html#tuple">tuple</a>;
    we can assign tuples to variables,
    and then use those variables in our programs to make our code easier to read:
  </p>

<pre>
from skimage import novice
<span class="highlight">image_size = (200, 200)</span>
all_red = novice.new(<span class="highlight">image_size</span>, (255, 0, 0))
all_red.show()
all_green = novice.new(<span class="highlight">image_size</span>, (0, 255, 0))
all_green.show()
all_blue = novice.new(<span class="highlight">image_size</span>, (0, 0, 255))
all_blue.show()
</pre>

  <p>
    One nice side effect of this is that it also makes our programs easier to change.
    If we want our images to be 300 pixels across instead of 200,
    we only have to change the value of <code>image_size</code>,
    and everything else just works.
    This is a basic rule of good program design:
    any given piece of information should be stored in one place, once,
    so that any change requires only one change in one place.
  </p>

  <p>
    <code>skimage.novice</code> lets us change image colors using properties as well.
    If we don't initially specify a color for an image,
    the image's pixels are all set to black:
  </p>

<pre>
from skimage import novice
image_size = (200, 200)
picture = novice.new(image_size)
</pre>

  <p>
    We can now change the red, green, or blue values of all its pixels like this
    (<a href="#f:color_properties">Figure XXX</a>):
  </p>

<pre>
picture.red   = 128
picture.green = 192
picture.blue  = 255
picture.show()
</pre>

  <figure id="f:color_properties">
    <img src="img/pymedia/color_properties.png" alt="Color Properties" />
  </figure>

</section>

<section id="s:pixels">

  <h2>Manipulating Pixels</h2>

  <p>
    Changing the color of the entire image at once is useful for creating backgrounds,
    but most pictures have more detail than that.
    If we want to change the color of a single pixel,
    we need a way to refer to it.
    In Python and most other languages,
    we do that by providing an <a href="glossary.html#index">index</a>,
    which is just the coordinates of the pixel we want to access.
    To create a red image with a single white pixel in the lower-left corner,
    we would do this:
  </p>

<pre>
from skimage import novice
block = novice.new((10, 10), (255, 0, 0))
block[0, 0] = (255, 255, 255)
block.show()
</pre>

  <p>
    The first thing to notice about this example is that the lower-left corner is at (0, 0),
    not at (1, 1).
    Programming languages derived from C (which includes C++, Java, Python, Perl, and Ruby)
    count from 0:
    the first five indices into anything are 0, 1, 2, 3, and 4.
    Some other languages (notably Fortran, MATLAB, and R) count from 1.
    The latter is more sensible&mdash;nobody says, "Zero, one, two, three, four," when counting their fingers&mdash;but
    we're stuck with the former for programming.
  </p>

  <p>
    The second thing to notice about this example is that a 10&times;10 image is hard to see,
    and a single white pixel is almost invisible.
    Let's try this:
  </p>

<pre>
from skimage import novice
block = novice.new((10, 10), (255, 0, 0))
block[0, 0] = (255, 255, 255)
<span class="highlight">block.inflation = 10</span>
block.show()
</pre>

  <p>
    An image's <code>inflation</code> property tells the library how large to make each pixel
    when displaying or saving the image.
    This doesn't change how many pixels there actually are,
    or how they're indexed;
    it's purely a convenience to help us see what we're doing.
  </p>

  <p>
    What if we want to make the upper-right pixel white instead?
    We happen to know that our image is 10&times;10,
    so we could do this:
  </p>

<pre>
block[9, 9] = (255, 255, 255)
</pre>

  <p class="continue">
    The upper-right index is (9, 9) because we're counting from 0:
    if the image is ten pixels across,
    its X coordinates are 0..9.
    This works in this specific case,
    but it's a bad long-term solution:
    if someone changes the size of the image,
    the upper-right pixel probably won't be at (9, 9) any longer,
    and we don't want to have to check our program line-by-line to find things like this.
  </p>

  <p>
    Here's one better solution:
  </p>

<pre>
block_width = 10
block_height = 10
block = novice.new((block_width, block_height), (255, 0, 0))
block[block_width - 1, block_height - 1] = (255, 255, 255)
</pre>

  <p>
    If someone changes the block's height or width now,
    the index expression in the last line will automatically adjust.
    This version of the program also makes the image's size a lot easier to find:
    instead of being buried inside a function call,
    <code>block</code>'s height and width are identified by name.
  </p>

  <p>
    We can improve this program even further like this:
  </p>

<pre>
block_width = 10
block_height = 10
<span class="highlight">red = (255, 0, 0)
white = (255, 255, 255)</span>
block = novice.new((block_width, block_height), <span class="highlight">red</span>)
block[block_width - 1, block_height - 1] = <span class="highlight">white</span>
</pre>

  <p class="continue">
    and then go one step further like this:
  </p>

<pre>
block_width = 10
block_height = 10
red = (255, 0, 0)
white = (255, 255, 255)
block = novice.new((block_width, block_height), red)
block[<span class="highlight">-1, -1</span>] = white
</pre>

  <p>
    Unlike most languages,
    Python is happy with negative indices:
    it uses them to count backward from the ends of things,
    rather than forward from the start
    (<a href="#f:negative_indices">Figure XXX</a>).
    Once you get used to it,
    it makes programs much easier to read&mdash;as the examples above show,
    the <code>-1</code> can be easy to miss when it's tacked onto the end of a long expression.
  </p>

  <figure id="f:negative_indices">
    <img src="img/pymedia/negative_indices.png" alt="Negative Indices" />
  </figure>

  <p>
    Now,
    what if we want to put a white border around our image?
    We could do this:
  </p>

<pre>
block[0, 0] = white
block[0, 1] = white
block[0, 2] = white
...
block[0, 9] = white
</pre>

  <p class="continue">
    and then repeat it for the other three sides
    but that would be a lot of work to type in,
    we'd probably make mistakes along the way,
    and if the image size changes,
    we'll have to add or remove dozens or hundreds of lines.
    Here's a better way:
  </p>

<pre>
block[0, :]  = white
block[-1, :] = white
block[:, 0]  = white
block[:, -1] = white
</pre>

  <p>
    As you can probably guess,
    ':' on its own means "all indices"&mdash;it's a <a href="shell.html#pipefilter">wildcard</a>,
    just like '*' in filenames in the shell.
    Behind the scenes,
    the computer is still executing something like our original code&mdash;after all,
    each of the pixels on the border does need to be modified somehow&mdash;but:
  </p>

  <ol>
    <li>
      this code is much faster to write,
    </li>
    <li>
      much more likely to be correct,
      and
    </li>
    <li>
      once the computer knows it's supposed to update all the pixels in a row or column,
      it can probably do it faster than we could by hand.
    <li>
  </ol>

  <p>
    ':' on its own is actually a special case of something much more general
    called a <a href="glossary.html#slice">slice</a>.
    If we run this program:
  </p>

<pre>
from skimage import novice
block_width = 200
block_height = 200
green = (0, 255, 0)
white = (255, 255, 255)
block = novice.new((block_width, block_height), green)
block[<span class="highlight">0:40, 0:40</span>] = white
</pre>

  <p class="continue">
    When we display this image,
    it is a single white tile in the lower-left of a green background
    (<a href="#f:single_tile">Figure XXX</a>):
  </p>

  <figure id="f:single_tile">
    <img src="img/pymedia/single_tile.png" alt="A Single Tile" />
  </figure>

  <p>
    You can probably guess that the expression <code>0:40</code> refers to
    a range of pixels:
    in this case, from index 0 to index 39 inclusive,
    i.e.,
    from the lower limit up to, but not including, the upper limit.
    It may seem strange not to include the upper limit,
    but it has several advantages:
  </p>

  <ol>
    <li>
      The number of values in <code>lower:upper</code> is <code>upper-lower</code>.
    </li>
    <li>
      When the ranges <code>lower:middle</code> and <code>middle:upper</code> are joined together,
      the pixel at coordinate <code>middle</code> is only included once.
    </li>
    <li>
      If the axis in question has <code>length</code> pixels,
      the expression <code>0:length</code> refers to each pixel exactly once.
    </li>
  </ol>

</section>

<section id="s:argv">

  <h2>Command-Line Arguments</h2>

  <div class="understand" id="u:argv">
    <h3>Understand:</h3>
    <ul>
      <li>How to work with command-line arguments.</li>
      <li>That slicing works in many places.</li>
    </ul>
  </div>

  <p>
    Let's go back to our thumbnail creation program for a moment.
    It would be much more useful if we could create a thumbnail of any image we wanted
    without having to edit the program each time to change the name of the file.
    What we want is something like this:
  </p>

<pre>
$ <span class="in">ls *.jpg</span>
<span class="out">mac.jpg</span>
$ <span class="in">python thumbnail mac.jpg</span>
$ <span class="in">ls *.jpg</span>
<span class="out">mac.jpg    thumb-mac.jpg</span>
</pre>

  <p>
    To make this work,
    we need a way to get filenames from the command line into our program.
    To do that,
    we need to use another library called <code>sys</code>
    (short for "system").
    It defines constants to tell us what version of Python we're using,
    what operating system we're running on,
    and so on:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">import sys</span>
&gt;&gt;&gt; <span class="in">print sys.version</span>
<span class="out">2.7 (r27:82525, Jul  4 2010, 09:01:59) [MSC v.1500 32 bit (Intel)]</span>
&gt;&gt;&gt; <span class="in">print sys.platform</span>
<span class="out">win32</span>
</pre>

  <p>
    The most commonly-used element of <code>sys</code>, though, is <code>sys.argv</code>,
    which holds the <a href="glossary.html#command-line-arguments">command-line arguments</a>
    used to run the program.
    These are accessed using indices,
    just like individual pixels;
    the biggest differences are that
    <code>sys.argv</code> is one-dimensional instead of two-dimensional,
    and that its values are strings rather than pixels.
    The name of the script itself is in <code>sys.argv[0]</code>;
    all the other arguments are put in <code>sys.argv[1]</code>, <code>sys.argv[2]</code>, and so on.
    For example, here's a program that does nothing except
    print its first three command-line arguments:
  </p>

<pre>
import sys
print 'location 0:', sys.argv[0]
print 'location 1:', sys.argv[1]
print 'location 2:', sys.argv[2]
</pre>

  <p>
    If we run save this code in a file called <code>three.py</code>,
    and run it like this:
  </p>

<pre>
$ <span class="in">python three.py alpha beta</span>
</pre>

  <p class="continue">
    it prints:
  </p>

<pre>
<span class="out">location 0: three.py
location 1: alpha
location 2: beta</span>
</pre>

  <p>
    However,
    if we run it with no arguments,
    or only one,
    we get this:
  </p>

<pre>
$ <span class="in">python three.py</span>
<span class="out">location 0: /Users/gwilson/three.py
location 1:</span>
<span class="err">Traceback (most recent call last):
  File "/Users/gwilson/three.py", line 3, in &lt;module&gt;
    print 'location 1:', sys.argv[1]
IndexError: list index out of range</span>
</pre>

  <p>
    The problem is that <code>sys.argv[1]</code> doesn't exist,
    and Python won't let us read a value that isn't there.
    It's exactly like the undefined variables we encountered at the start of this chapter.
  </p>

  <p>
    Let's ignore that problem for now
    and go back to our thumbnail creator.
    Here's how we can make it work for an arbitrary file:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

filename = sys.argv[1]
picture = novice.open(filename)
new_height = picture.height * fixed_width / picture.width
picture.height = new_height
picture.width = fixed_width
picture.save('thumb-' + filename)
</pre>

  <p>
    Let's walk through it piece by piece:
  </p>

  <ul>
    <li>
      We start by importing the libraries we need.
      <code>import</code> statements can actually be anywhere in the program,
      but it's considered good style to put them at the top,
      as it makes it easy for people to see what the program depends on.
    </li>
    <li>
      We give the fixed width we want thumbnails to have a name,
      so that we don't have to scatter the number 30 throughout the program.
      Values that are meant to be constants are usually written in UPPER CASE;
      again,
      it's not a requirement,
      but it's what most people do,
      so by sticking to this convention you will make it easier for other people to understand your code.
    </li>
    <li>
      The name of the image to be thumbnailed is supposed to be the program's single command-line argument,
      which means it will be in <code>sys.argv[1]</code>.
      (Remember, the program's name is in <code>sys.argv[0]</code>.)
      We could just use <code>sys.argv[1]</code> everywhere,
      but assigning the value to the variable <code>filename</code> makes our program easier to follow.
    </li>
    <li>
      We calculate the picture's new size
      and resize the picture as before.
    </li>
    <li>
      Finally,
      we create the new filename by concatenating <code>'thumb-'</code> and the original filename,
      and save the thumbnail to that file.
    </li>
  </ul>

</section>

<section id="s:for">

  <h2>Repeating Things</h2>

  <div class="understand" id="u:for">
    <h3>Understand:</h3>
    <ul>
      <li>How to repeat things using a loop.</li>
      <li>That the loop variable takes on a different value each time through the loop.</li>
      <li>How to tell what statements are in the body of a loop.</li>
    </ul>
  </div>

  <p>
    Computers are useful because they can do lots of calculations on lots of data,
    which means we need a concise way to represent multiple steps.
    (After all,
    writing out a million additions would take longer than doing them.)
    Let's start by writing a program called <code>show.py</code>
    that displays its command-line arguments one by one:
  </p>

<pre>
import sys
for arg in sys.argv:
    print arg
</pre>

  <p>
    Here's what happens when we run it:
  </p>

<pre>
$ <span class="in">python show.py first second third</span>
<span class="out">show.py
first
second
third</span>
</pre>

  <p>
    The keywords <code>for</code> and <code>in</code> are used to create a <a href="glossary.html#for-loop">for loop</a>.
    Just like a <a href="shell.html#loop">loop in the shell</a>,
    a <code>for</code> loop in Python repeats one or more instructions
    for each value in some set.
    The indented line is called the <a href="glossary.html#loop-body">body</a> of the loop:
    it's the command that Python executes repeatedly.
    The variable <code>arg</code> is sometimes called
    the <a href="glossary.html#loop-variable">loop variable</a>.
    There's nothing special about its name:
    we could equally well have called it <code>something</code>.
    What's important is that the <code>for</code> loop repeatedly
    assigns a value to it,
    then executes the loop body one more time.
  </p>

  <p>
    Python always uses indentation to show what's in the body of a loop
    (or anything else&mdash;we'll see other things that have bodies soon).
    This means that:
  </p>

<pre>
for arg in sys.argv:
    print arg
    print "all done"
</pre>

   <p class="continue">
     and:
   </p>

<pre>
for arg in sys.argv:
    print arg
print "all done"
</pre>

  <p class="continue">
    are different programs.
    The first one would print:
  </p>

<pre>
<span class="out">show.py
all done
first
all done
second
all done
third
all done</span>
</pre>

  <p class="continue">
    because the statement <code>print "all done"</code> is inside the loop body.
    The second is probably what we actually want,
    as it prints:
  </p>

<pre>
<span class="out">show.py
first
second
third
all done</span>
</pre>

  <p class="continue">
    because the final <code>print</code> is outside the loop.
  </p>

  <div class="box">

    <h3>Why Indentation?</h3>

    <p>
      Most other languages use visible markers to show the beginnings and ends of loop bodies,
      such as the <code>do</code> and <code>done</code> of the shell.
      Python uses indentation because studies done in the 1970s and 1980s showed
      that's what people actually pay attention to.
      If we write something as:
    </p>

<pre>
for value in data
do
    print value
print "done"
done
</pre>

    <p class="continue">
      then most people reading the code in a hurry will "see"
      the second <code>print</code> statement as being outside the loop.
    </p>

  </div>

  <p>
    Let's go back and teach our thumbnail program how to process multiple files at once:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

for filename in sys.argv:
    picture = novice.open(filename)
    new_height = picture.height * fixed_width / picture.width
    picture.height = new_height
    picture.width = fixed_width
    picture.save('thumb-' + filename)
</pre>

  <p>
    Almost everything has stayed the same:
    the only change is that instead of assigning <code>sys.argv[1]</code> to <code>filename</code>,
    we're using a loop to assign it each value in <code>sys.argv</code> in turn.
    Let's try running it:
  </p>

<pre>
$ <span class="in">python thumbnail.py flower.jpg mac.jpg</span>
<span class="err">Traceback (most recent call last):
...several lines of error message...
IOError: cannot identify image file</span>
</pre>

  <p>
    Whoops:
    the first time through the loop,
    <code>filename</code> is assigned <code>sys.argv[0]</code>,
    which is the name of the Python program itself.
    The <code>novice.open</code> call then tries to open a Python program
    (i.e., a text file)
    as if it were an image.
    Unsurprisingly,
    that doesn't work.
  </p>

  <p>
    How can we fix this?
    By using a slice that starts at index 1
    and runs to the end of the list of filenames:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

for filename in sys.argv<span class="in">[1:len(sys.argv)]</span>:
    picture = novice.open(filename)
    new_height = picture.height * fixed_width / picture.width
    picture.height = new_height
    picture.width = fixed_width
    picture.save('thumb-' + filename)
</pre>

  <p class="continue">
    Remember,
    a slice starts at its low index,
    and goes up to, but not including, its upper index.
    The expression <code>stuff[1:len(stuff)]</code> is therefore
    everything in <code>stuff</code> except the element at location zero
    (<a href="#f:all_but_the_first">Figure XXX</a>):
  </p>

  <figure id="f:all_but_the_first">
    <img src="img/pymedia/all_but_the_first.png" alt="All But The First Element" />
  </figure>

  <p>
    We can make this even simpler.
    If we don't specify the lower end of a slice,
    it defaults to 0,
    so <code>stuff[:3]</code> is elements 0, 1, and 2 of <code>stuff</code>.
    Similarly,
    if we don't specify the slice's upper end,
    it defaults to the end,
    so <code>stuff[3:]</code> is elements 3, 4, 5, and so on to the end.
    In particular,
    <code>stuff[1:]</code> is everything in <code>stuff</code> except the element at index 0,
    so we can rewrite our thumbnailer one more time as:
  </p>

<pre>
import sys
from skimage import novice

FIXED_WIDTH = 30

for filename in sys.argv<span class="in">[1:]</span>:
    picture = novice.open(filename)
    new_height = picture.height * fixed_width / picture.width
    picture.height = new_height
    picture.width = fixed_width
    picture.save('thumb-' + filename)
</pre>

  <div class="box">
    <h3>One Thing, Many Uses</h3>

    <p>
      Slices are a good example of a powerful idea in program design:
      if something works in one place,
      it ought to work everywhere.
      For example,
      if we want to select the first four characters from a string,
      you shouldn't be surprised that we do it like this:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">full_name = 'Alan Turing'</span>
&gt;&gt;&gt; <span class="in">first_name = full_name[:4]</span>
&gt;&gt;&gt; <span class="in">print first_name</span>
<span class="out">Alan</span>
</pre>

    <p class="continue">
      or that if we want to print each character from the string
      on a line of its own,
      we use:
    </p>

<pre>
&gt;&gt;&gt; <span class="in">for char in 'Alan':
...     print char</span>
<span class="out">A
l
a
n</span>
</pre>

  </div>

  <p>
    Here's something else we can do with a loop:
  </p>

<pre>
from skimage import novice

picture = novice.open('mac.jpg')
picture.show()
for pixel in picture:
    pixel.red = pixel.red / 2
picture.show()
</pre>

  <p>
    <a href="#f:less_red">Figure XXX</a> shows the original and modified images side by side.
    The second version looks bluish-green
    because the amount of red in each pixel has been cut in half.
    That's what the <code>for</code> loop has done:
    each time through the loop,
    <code>pixel</code> has been assigned the next pixel in the image,
    and the statement:
  </p>

<pre>
    pixel.red = pixel.red / 2
</pre>

  <p class="continue">
    has half the original value of the pixel's <code>red</code> property
    and assigned it back to the pixel.
  </p>

  <figure id="f:less_red">
    <img src="img/pymedia/less_red.png" alt="Reducing the Red" />
  </figure>

  <p>
    What happens if we try to double the red instead?
  </p>

<pre>
&gt;&gt;&gt; <span class="in">picture = novice.open('mac.jpg')
&gt;&gt;&gt; for pixel in picture:
...    pixel.red = pixel.red * 2
...</span>
<span class="err">
Traceback (most recent call last):
...several lines of error message...
ValueError: Expected an integer between 0 and 255, but got 294 instead!</span>
</pre>

  <p class="continue">
    Just as Python won't let us use an index that's out of range,
    <code>skimage.novice</code> won't let us assign a color value
    that's out of the range from 0 to 255.
    If we want to make sure the value is in that range,
    we can do this instead:
  </p>

<pre>
picture = novice.open('mac.jpg')
for pixel in picture:
    pixel.red = min(255, pixel.red * 2)
</pre>

  <p>
    This works,
    and gives the result shown in <a href="#f:more_red">Figure XXX</a>.
  </p>

  <figure id="f:more_red">
    <img src="img/pymedia/more_red.png" alt="Increasing the Red" />
  </figure>

  <div class="keypoints" id="k:for">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>for <em>variable</em> in <em>something</em>:</code> to loop over the parts of something.</li>
      <li>The body of a loop must be indented consistently.</li>
      <li>The parts of a string are its characters; the parts of an image are its pixels.</li>
    </ul>
  </div>

</section>

<section id="s:logic">

  <h2>Making Choices</h2>

  <div class="understand" id="u:logic">
    <h3>Understand:</h3>
    <ul>
      <li>How to choose what statements to execute using conditionals.</li>
      <li>How to combine conditional tests.</li>
      <li>What an in-place operator is.</li>
    </ul>
  </div>

  <p>
    Using the <code>min</code> function is one way to clip values.
    Another is to use a <a href="glossary.html#conditional">conditional</a> statement.
    Let's start with a simple example:
  </p>

<pre>
if 5 &gt; 0:
    print '5 is greater than 0'

if 5 &lt; 0:
    print '5 is less than 0'
</pre>

  <p>
    When we run this program,
    it prints:
  </p>

<pre>
<span class="out">5 is greater than 0</span>
</pre>

  <p class="continue">
    The logic is fairly easy to follow.
    The keyword <code>if</code> is followed by an expression.
    If that expression is true,
    Python executes the indented block of code,
    but if the expression is false,
    it doesn't.
    In this case,
    since 5 actually is greater than 0,
    the first <code>print</code> statement is run,
    but not the second.
  </p>

  <p>
    Now let's try this:
  </p>

<pre>
for char in 'GATTACA':
    if char == 'A':
        print 'found an A'
<span class="out">found an A
found an A
found an A</span>
</pre>

  <p>
    Python uses a double equals sign '==' to test for equality
    (because the single equals sign '=' is used for assignment).
    Each time through the loop above,
    it compares the current value of <code>char</code> to the character 'A'.
    When the two are equal,
    it prints a message;
    since the letter appears three times in 'GATTACA',
    the message is printed three times.
  </p>

  <p>
    All right,
    how about this?

<pre>
VOWELS = 'AEIOU'
num_vowels = 0
num_other = 0
for char in 'GATTACA':
    if char in VOWELS:
        num_vowels = num_vowels + 1
    else:
        num_other = num_other + 1
print num_vowels, 'vowels'
print num_other, 'other characters'
<span class="out">3 vowels
4 other characters</span>
</pre>

  <p>
    This little program introduces two new language features.
    The first is the <code>in</code> operator,
    which,
    as its name suggests,
    tests whether one value is in another.
    In this case,
    we're using it to see if the current character is in our list of vowels.
  </p>

  <p>
    The other feature is the keyword <code>else</code>,
    which is used to introduce an alternative to an <code>if</code>.
    Here,
    if a character is a vowel,
    Python increments <code>num_vowels</code>.
    If that test fails&mdash;i.e., if the character <em>isn't</em> in <code>VOWELS</code>&mdash;Python
    executes the both of the <code>else</code>
    and increments <code>num_other</code> instead.
  </p>

  <p>
    We can make this program a bit more readable by writing the body of the loop like this:
  </p>

<pre>
for char in 'GATTACA':
    if char in VOWELS:
        <span class="highlight">num_vowels += 1</span>
    else:
        <span class="highlight">num_other += 1</span>
</pre>

  <p>
    The notation <code>x += 1</code> means, "Add one to the variable <code>x</code>."
    This is called an <a href="glossary.html#in-place-operator">in-place operator</a>;
    we can similarly use <code>x += 5</code> to add 5 to <code>x</code>,
    <code>x *= 3</code> to triple it,
    and so on.
    It may seem like a small saving,
    but it actually prevents a lot of bugs
    by eliminating duplicated code.
  </p>

  <p>
    With conditionals in hand,
    let's go back and rewrite our reddening program:
  </p>

<pre>
picture = novice.open('mac.jpg')
for pixel in picture:
    if pixel.red &lt; 128:
        pixel.red *= 2
    else:
        pixel.red = 255
</pre>

</section>

<section id="s:lists">

  <h2>Lists</h2>

  <div class="understand" id="u:lists">
    <h3>Understand:</h3>
    <ul>
      <li>How to store many related values in a list.</li>
      <li>How to use a loop to operate on the values in a list.</li>
      <li>That programs should be tested on small, simple cases.</li>
    </ul>
  </div>

  <p>
    It's time to double back and have a closer look at <code>sys.argv</code>.
    It's obviously not an image;
    instead,
    it's a <a href="glossary.html#list">list</a>.
    To start our exploration of lists,
    let's run an interpreter and try this:
  </p>

<pre src="src/python/sum_values.py">
&gt;&gt;&gt; <span class="in">data = [1, 3, 5]</span>
&gt;&gt;&gt; <span class="in">for value in data:</span>
... <span class="in">    print value</span>
...
<span class="out">1
3
5</span>
</pre>

  <p>
    <code>[1, 3, 5]</code> is a list:
    a single object that stores multiple values
    (<a href="#f:simple_list">Figure XXX</a>).
    Just as a <code>for</code> loop over an open file
    reads lines from that file one by one
    and assigns them to the loop variable,
    a <code>for</code> loop over a list assigns each value in the list
    to the loop variable in turn.
  </p>

  <figure id="f:simple_list">
    <img src="img/python/simple_list.png" alt="A Simple List" />
  </figure>

  <p>
    Let's do something a bit more useful:
  </p>

<pre src="src/python/first_mean.py">
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = total / len(data)
print "mean is", mean
<span class="out">mean is 2</span>
</pre>

  <p class="continue">
    This loop adds each value in the list to <code>total</code>.
    Once the loop is over,
    we divide <code>total</code> by the length of the list,
    which we find using the built-in function <code>len</code>.
  </p>

  <p>
    Unfortunately,
    the result in the example above is wrong:
    The total of the numbers in the list is 25,
    but we're printing 2 instead of 25/9
    (which is 2.7777&hellip;).
    The problem once again is that we're dividing one integer by another,
    which throws away the remainder.
    We can fix this by initializing <code>total</code> to 0.0
    (so that all the additions involve a floating-point number and an integer,
    which produces a floating-point number),
    or by using the <code>float</code> function to do the conversion explicitly:
  </p>

<pre src="src/python/second_mean.py">
data = [1, 4, 2, 3, 3, 4, 3, 4, 1]
total = 0
for n in data:
    total += n
mean = <span class="highlight">float(total)</span> / len(data)
print "mean is", mean
<span class="out">mean is 2.77777777778</span>
</pre>

  <p>
    The <em>real</em> problem isn't a matter of integers versus floats, though.
    The real problem with this program is that
    we didn't know whether the answer was right or wrong,
    so we couldn't tell if the program was correct or not.
    After all,
    the average of these nine numbers might well have been 2.
  </p>

  <p>
    The fact that a program runs without crashing doesn't mean it's correct.
    One way to make programs easier to check
    is to run them on smaller or more regular data.
    For example,
    If we ran the program on <code>[1, 4]</code>,
    we'd probably notice that we were getting 2 instead of 2.5.
    Writing programs so that they're checkable is another idea
    that we'll explore in detail <a href="quality.html">later</a>.
  </p>

  <div class="box">

    <h3>Even Simpler</h3>

    <p>
      Python actually has a built-in function called <code>sum</code>,
      so we can get rid of the loop entirely:
    </p>

<pre src="src/python/loopless.py">
total = sum(data)
print "mean is", float(total) / len(data)
</pre>

    <p class="continue">
      and shorten this even further by calling <code>float</code>
      directly on the result of <code>sum</code>:
    </p>

<pre src="src/python/one_liner.py">
print "mean is", float(sum(data)) / len(data)
</pre>

    <p>
      <code>float(sum(data))</code> is like <em>sin(log(x))</em>:
      the inner function is evaluated first,
      and its result is used as the input to the outer function.
      It's important to get the parentheses in the right place,
      since the expressions:
    </p>

<pre src="src/python/one_liner.py">
float(sum(data)) / len(data)
</pre>

    <p class="continue">
      and
    </p>

<pre src="src/python/incorrect_one_liner.py">
float(sum(data) / len(data))
</pre>

    <p class="continue">
      calculate different things.
      In the first,
      <code>float</code> is applied to <code>sum(data)</code>,
      i.e.,
      Python adds up all the numbers,
      then converts the result to a floating-point value
      before dividing by <code>len(data)</code>
      to get the mean.
    </p>

    <p>
      In the second,
      Python adds up the numbers,
      divides by <code>len(data)</code> to get an integer result,
      and then converts that integer to a floating point number.
      This is just our original bug in a more compact form.
      Once again,
      the only way to guard against it is to test the program.
    </p>

  </div>

  <div class="keypoints" id="k:lists">
    <h3>Summary</h3>
    <ul>
      <li>Use <code>[<em>value</em>, <em>value</em>, ...]</code> to create a list of values.</li>
      <li><code>for</code> loops process the elements of a list, in order.</li>
      <li><code>len(<em>list</em>)</code> returns the length of a list.</li>
      <li><code>[]</code> is an empty list with no values.</li>
    </ul>
  </div>

</section>

<section id="s:morelist">

  <h2>More About Lists</h2>

  <div class="understand" id="u:morelist">
    <h3>Understand:</h3>
    <ul>
      <li>That lists can be modified in place.</li>
      <li>How to access arbitrary elements in a list.</li>
      <li>What an out-of-bounds error is.</li>
      <li>How to generate a list of legal indices for a list.</li>
      <li>When to use short or long variable names.</li>
    </ul>
  </div>

  <p>
    Lists (and their equivalents in other languages)
    are used more than any other data structure,
    so let's have a closer look at them.
    First,
    lists are <a href="glossary.html#mutable">mutable</a>,
    i.e.,
    they can be changed after they are created:
  </p>

<pre src="src/python/appending.py">
data = [1, 4, 2, 3]
result = []
current = 0
for n in data:
    current = current + n
    result.append(current)
print "running total:", result
<span class="out">[1, 5, 7, 10]</span>
</pre>

  <p class="continue">
    <code>result</code> starts off as an <a href="glossary.html#empty-list">empty list</a>,
    and <code>current</code> starts off as zero
    (<a href="#f:running_total">Figure XXX</a>).
    Each time the loop executes&mdash;i.e.,
    for each number in <code>values</code>&mdash;Python
    adds the next value in the list to <code>current</code>
    to calculate the running total.
    It then append this value to <code>result</code>,
    so that when the program finishes,
    we have a complete list of partial sums.
  </p>

  <figure id="f:running_total">
    <img src="img/python/running_total.png" alt="Running Total" />
  </figure>

  <p>
    What if we want to double the values in <code>data</code> in place?
    We could try this:
  </p>

<pre src="src/python/incorrect_doubling_in_place.py">
data = [1, 4, 2, 3]
for n in data:
    n = 2 * n
print "doubled data is:", data
<span class="out">doubled data is [1, 4, 2, 3]</span>
</pre>

  <p class="continue">
    but as we can see,
    it doesn't work.
    When Python calculates <code>2*n</code>,
    it creates a new value in memory
    (<a href="#f:doubling_list">Figure XXX</a>).
    It then makes the variable <code>n</code> point at the value for a few microseconds
    before going around the loop again
    and pointing <code>n</code> at the next value from the list instead.
    Since nothing is pointing to the temporary value we just created any longer,
    Python throws it away.
  </p>

  <figure id="f:doubling_list">
    <img src="img/python/doubling_list.png" alt="Failed Attempt to Double Values in a List" />
  </figure>

  <p>
    The solution to our problem is,
    not surprisingly,
    to index the list.
    Here are some examples:
  </p>

<pre src="src/python/modify_list.py">
scientists = ["Newton", "Darwing", "Turing"]
print "length:", len(scientists)
<span class="out">length: 3</span>
print "first element:", scientists[0]
<span class="out">first element: Newton</span>
print "second element:", scientists[1]
<span class="out">second element: Darwing</span>
print "third element:", scientists[2]
<span class="out">third element: Turing</span>
</pre>

  <p>
    How does indexing help us?
    Well,
    after noticing that we have misspelled Darwin's name as "Darwing",
    we can fix it by assigning a new value to that location in the list:
  </p>

<pre src="src/python/modify_list_continued.py">
scientists[1] = "Darwin"
print scientists
<span class="out">["Newton", "Darwin", "Turing"]</span>
</pre>

  <p class="continue">
    <a href="#f:update_list">Figure XXX</a> shows
    the list before and after the change.
    Again,
    once we've made the update,
    nothing is pointing to the string "Darwing" with a "g" on the end,
    so the memory it's using is recycled.
  </p>

  <figure id="f:update_list">
    <img src="img/python/update_list.png" alt="Successfully Doubling Values in a List" />
  </figure>

  <p>
    Now, back to our original problem of doubling values in place.
    We now know that we can do this:
  </p>

<pre src="src/python/explicit_doubling.py">
data = [1, 4, 2]
data[0] = 2 * data[0]
data[1] = 2 * data[1]
data[2] = 2 * data[2]
print "doubled data is:", data
<span class="out">doubled data is [2, 8, 4]</span>
</pre>

  <p class="continue">
    but it clearly doesn't scale:
    we're not going to write a million statements
    to update a list of a million values.
    We need to use a loop,
    but instead of looping over the values in the list,
    we want to loop over the allowed indices of the list.
    To do this,
    we will rely on a function called <code>range</code>
    which creates a list of the first N integers:
  </p>

<pre src="src/python/range_5.py">
print range(5)
<span class="out">[0, 1, 2, 3, 4]</span>
</pre>

  <p>
    Once again,
    the values go from 0 to one less than the number given to <code>range</code>,
    which just happens to be exactly the indices of a list of that length.
    Let's try it out:
  </p>

<pre src="src/python/range_loop.py">
data = [1, 4, 2]
indices = range(3)
for i in indices:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p class="continue">
    then fold the call to <code>range</code> into the loop:
  </p>

<pre src="src/python/range_loop_2.py">
data = [1, 4, 2]
for i in <span class="highlight">range(3)</span>:
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    This program is correct, but fragile:
    if we add more values to the list,
    Python will still only execute the loop three times,
    so we'll still only print the first three values in the list:
  </p>

<pre src="src/python/incorrect_range_loop.py">
data = [1, 4, 2<span class="highlight">, 5, 1, 3</span>]
for i in range(3):
    print i, data[i]
<span class="out">0 1
1 4
2 2</span>
</pre>

  <p>
    What we want is for the loop to automatically adjust itself
    based on the length of the list:
  </p>

<pre src="src/python/data_length_loop.py">
data = [1, 4, 2, 5, 1, 3]
<span class="highlight">data_length = len(data)</span>
for i in range(<span class="highlight">data_length</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p>
    We can get rid of the variable <code>data_length</code>
    by putting the call to <code>len(data)</code>
    inside the call to <code>range</code>:
  </p>

<pre src="src/python/idiomatic_range_loop.py">
data = [1, 4, 2, 5, 1, 3]
for i in range(<span class="highlight">len(data)</span>):
    print i, data[i]
<span class="out">0 1
1 4
2 2
3 5
4 1
5 3</span>
</pre>

  <p class="continue">
    Again,
    <code>range(len(data))</code> is like <em>sin(log(x))</em>:
    the inner function is evaluated first,
    and its result becomes the input to the outer function.
    Put together like this,
    they are a common <a href="glossary.html#idiom">idiom</a> in Python,
    i.e.,
    a way of saying something that everyone recognizes and uses.
    When an experienced programmer sees:
  </p>

<pre>
for i in range(len(something)):
</pre>

  <p class="continue">
    what she "hears" is:
  </p>

<pre>
for each legal index of something:
</pre>

  <p>
    The reason this idiom is better than what we started with is that
    there is no duplicated information.
    Instead of having a list of length 3,
    and looping from 0 up to 3,
    we have a list of any length whatever,
    and loop from 0 up to that length.
    In general,
    anything that is repeated two or more times in a program
    will eventually be wrong in at least one.
    Putting it another way,
    any piece of information should appear exactly once in a program,
    so that if it needs to change,
    it only needs to be changed in one place.
  </p>
  
  <div class="box">

    <h3>Short and Long Variable Names</h3>

    <p>
      We have said several times that programs should use meaningful variable names.
      Are we not violating our own rule by using <code>i</code> as a variable in this program?
      The short answer is "yes", but it's a defensible violation.
      Suppose we re-write our loop as:
    </p>

<pre>
data = [1, 4, 2, 5, 1, 3]
for location in range(len(data)):
    print location, data[location]
</pre>

    <p class="continue">
      The longer name are more meaningful,
      but it also takes longer to read.
      Since the original <code>i</code> is only used for a few lines,
      users will easily be able to keep its meaning in short-term memory
      as long as they need to.
      On balance,
      therefore,
      the short name are better in this case.
    </p>

    <p>
      This is actually a general principle in program design.
      A variable that holds a simple value,
      and is only used in a few adjacent lines of code,
      can (and usually should) have a short name.
      A variable that holds a complex value,
      or one which is used over more than a few lines of code,
      should have a longer name
      in order to optimize the tradeoff between reading speed
      and the limitations of human short-term memory.
    </p>

  </div>

    <!-- JK: Also, to hearken back to the previous paragraph, the use of i as a 
         counter in a for loop is arguably another common idiom that 
         experienced programmers will recognize right away as a counter. At 
         least if they're not also mathematicians who read it as an imaginary 
         number... -->

  <p>
    Let's finally go back and double the values in place:
  </p>

<pre src="src/python/doubling_in_place.py">
data = [1, 4, 2, 5, 3, 4, 5]
for i in range(len(data)):
    data[i] = 2 * data[i]
print data
<span class="out">[2, 8, 4, 10, 6, 8, 10]</span>
</pre>

<div class="box">

  <h3>Left and Right</h3>

  <p>
    Seeing the expression <em>x = 2x</em>,
    most mathematicians would say,
    "Right&mdash;so <em>x</em> is zero."
    Seeing the same expression,
    most programmers would say,
    "Right&mdash;you're doubling the value of <em>x</em>."
    <a href="#f:double_in_place">Figure XXX</a> shows
    how that actually works:
  </p>

  <ol>

    <li>
      Python reads the current value of <code>x</code> from memory.
    </li>

    <li>
      It multiplies that value by 2,
      storing the result in a temporary location&hellip;
    </li>

    <li>
      &hellip;and then modifies <code>x</code> to point at the new value.
    </li>

  </ol>

  <figure id="f:double_in_place">
    <img src="img/python/double_in_place.png" alt="Doubling in Place" />
  </figure>

  <p>
    Now look at what happens when Python execute the statements:
  </p>

<pre>
x = 5
y = x
x = 2 * x
</pre>

<ol>

  <li>
    The variable <code>x</code> is created,
    and set to point at the value 5
    (<a href="#f:new_values_for_variables">Figure XXX</a>).
  </li>

  <li>
    The variable <code>y</code> is created,
    and set to point at the same value.
  </li>

  <li>
    The value 10 (i.e., 2&times;5) is created and stored in a temporary location.
  </li>

  <li>
    <code>x</code> is altered to point at that value.
  </li>

</ol>

<figure id="f:new_values_for_variables">
  <img src="img/python/new_values_for_variables.png" alt="New Values for Variables" />
</figure>

  <p>
    After these operations are complete,
    <code>y</code> is left pointing at the original value, 5.
    It does <em>not</em> point at the same thing <code>x</code> does any longer,
    and its value is <em>not</em> automatically recalculated
    to keep it twice the value of <code>x</code>.
  </p>

</div>

<div class="keypoints" id="k:morelist">
  <h3>Summary</h3>
  <ul>
    <li>Lists are mutable: they can be changed in place.</li>
    <li>Use <code><em>list</em>.append(<em>value</em>)</code> to append something to the end of a list.</li>
    <li>Use <code><em>list</em>[<em>index</em>]</code> to access a list element by location.</li>
    <li>The index of the first element of a list is 0; the index of the last element is <code>len(<em>list</em>)-1</code>.</li>
    <li>Negative indices count backward from the end of the list, so <code><em>list</em>[-1]</code> is the last element.</li>
    <li>Trying to access an element with an out-of-bounds index is an error.</li>
    <li><code>range(<em>number</em>)</code> produces the list of numbers <code>[0, 1, ..., <em>number</em>-1]</code>.</li>
    <li><code>range(len(<em>list</em>))</code> produces the list of legal indices for <code><em>list</em></code>.</li>
  </ul>
</div>

</section>

<section id="s:coords">

  <h2>Coordinates</h2>

  <div class="understand" id="u:coords">
    <h3>Understand:</h3>
    <ul>
      <li class="fixme">Write something</li>
    </ul>
  </div>

  <p>
    Let's try an experiment in two parts.
    First,
    run this program and look at the image files it creates:
  </p>

<pre>
from skimage import novice

BASE    = 128
STEP    = 4
SPACING = 4
NUMBER  = 6
GRAY    = (BASE, BASE, BASE)
SIZE    = 200

for color in range(BASE + STEP, BASE + NUMBER * STEP, STEP):
    image = novice.new((SIZE, SIZE), GRAY)
    image[::SPACING, ::SPACING] = (color, color, color)
    filename = 'step-' + str(color) + '.png'
    image.save(filename)
</pre>

  <p>
    These files have named like <code>step-132.png</code>,
    <code>step-136.png</code>,
    and so on.
    Each one has white pixels spaced evenly across a gray background,
    with the white slowly getting whiter.
    Images like these are sometimes used in vision tests,
    since different spacings and colorings are noticeable to different people.
  </p>

  <p>
    Having told you that,
    we've spoiled the second part of our experiment,
    which is to see how much knowing what a program does
    helps you figure out how it works.
    As you might suspect,
    the answer is, "A lot."
    Let's go through this one.
  </p>

  <p>
    The constants at the top don't tell us much,
    although <code>GRAY</code> is obviously an RGB color value
    and <code>SIZE</code> is (probably) an image size.
    Next is our loop:
    given the name of its index variable,
    <code>color</code>,
    we can guess that we're looping over colors,
    and sure enough,
    two lines down,
    we see <code>(color, color, color)</code>,
    which is creating a shade of gray defined by the current value of <code>color</code>.
  </p>

  <p>
    Backing up a line,
    we're creating a <code>SIZE</code>&times;<code>SIZE</code> image using <code>novice.new</code>
    and setting all its pixels to the fixed color <code>GRAY</code>.
    We're then&mdash;hm.
    What does <code>::SPACING</code> do?
    If it was <code>:SPACING</code> (with a single colon),
    it would mean,
    "From the start up to <code>SPACING</code>,"
    but there's a double colon there.
  </p>

  <p>
    The answer is that Python ranges can actually have three parts:
    the start,
    the end,
    and the <a href="glossary.html#stride">stride</a>,
    which is the separation between each entry.
    We can find out more about this inside the interpreter
    using the built-in <code>help</code> function:
  </p>

<pre>
&gt;&gt;&gt; <span class="in">help(range)</span>
<span class="out">range(...)
    range([start,] stop[, step]) -> list of integers
    
    Return a list containing an arithmetic progression of integers.
    range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.
    When step is given, it specifies the increment (or decrement).
    For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!
    These are exactly the valid indices for a list of 4 elements.</span>
</pre>

  <p class="continue">
    However,
    that doesn't tell us that strides also work in indices:
    that's something we just have to know.
  </p>

  <p>
    So,
    going back to our program,
    the key lines are:
  </p>

<pre>
for color in range(BASE + STEP, BASE + NUMBER * STEP, STEP):
    ...create image...
    image[::SPACING, ::SPACING] = (color, color, color)
</pre>

  <p class="continue">
    The loop is going from <code>BASE + STEP</code> up to <code>BASE + NUMBER * STEP</code>
    in increments of <code>STEP</code>.
    <code>BASE</code> is 128&mdash;our initial shade of gray.
    <code>STEP</code> is 4:
    that's the increment each time we go around the loop.
    And <code>NUMBER</code> is how many we're doing,
    so this loop is creating a bunch of images with the same gray background,
    but whiter and whiter points spaced at equal intervals across them.
  </p>

  <div class="keypoints" id="k:coords">
    <h3>Summary</h3>
    <ul>
      <li class="fixme">Write something</li>
    </ul>
  </div>

</section>

<section id="s:nestloop">

  <h2>Nesting Loops</h2>

  <div class="understand" id="u:nestloop">
    <h3>Understand:</h3>
    <ul>
      <li>That loops can be nested to operate on combinations of items.</li>
      <li>That the range of inner loops can depend on the state of outer loops.</li>
      <li>That doing this allows programs to handle more cases without changes.</li>
    </ul>
  </div>

  <p class="fixme">
    Explain nested loops in terms of triangles on images.
  </p>

</section>

<section id="s:puzzle">

  <h2>Cutting Up Images</h2>

  <p>
    We now have everything we need to solve Valerie's original problem,
    which is to cut an image into pieces
    and colorize those pieces in different ways.
    First,
    let's figure out what our input file is,
    and how many pieces we want along the X and Y axes:
  </p>

<pre>
import sys
from skimage import novice

if len(sys.argv) != 4:
    print 'Expected source filename and number of tiles on X and Y'
    sys.exit(1)

original_filename = sys.argv[1]
tile_x = int(sys.argv[2])
tile_y = int(sys.argv[3])
</pre>

  <p>
    After importing our libraries,
    this program checks that it has the right number of arguments.
    (Once again,
    the number is 4 because <code>sys.argv[0]</code> is the name of the program.)
    If something is wrong,
    the program prints an error message and exits.
    <span class="fixme">explain why 1</span>
    It then stores the name of the source file in <code>original_filename</code>,
    and converts the other two arguments to integers.
  </p>

<pre>
original = novice.open(original_filename)
size_x = original.width / tile_x
size_y = original.height / tile_y
if (size_x == 0) or (size_y == 0):
    print 'Cannot create that many tiles.'
    sys.exit(1)
</pre>

  <p>
    Here,
    the program opens the source file
    and figures out how large each tile is going to be along the X and Y axes.
    Once again,
    it checks to make sure the answer is reasonable:
    if,
    for example,
    we ask for 2000 tiles along an axis that's 200 pixels large,
    the integer-over-integer division will set the size to zero,
    and we should exit right away.
  </p>

<pre>
for x in range(0, size_x * tile_x, size_x):
    for y in range(0, size_y * tile_y, size_y):
        tile = novice.new((size_x, size_y))
        tile[:, :] = original[x:x+size_x, y:y+size_y]
        tile_filename = str(x) + '-' + str(y) + '-' + original_filename
        tile.save(tile_filename)
</pre>

  <p>
    This nested loop creates our slices.
    The loop variables <code>x</code> and <code>y</code> are coordinates of
    the lower-left corners of the slices;
    for each combination of their values,
    we create a new blank image
    (which we assign to <code>tile</code>),
    then copy over a section of the original image.
    We then construct a filename like
    <code>100-140-bicycle.jpg</code>
    and save that tile.
  </p>

</section>

{% endblock content %}
