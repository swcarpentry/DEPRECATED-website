{% extends "_base.html" %}

{% block file_metadata %}
  <meta name="title" content="Web Programming in Python" />
{% endblock file_metadata %}

{% block content %}
    <ol class="toc">
      <li><a href="#s:history">How We Got Here</a></li>
      <li><a href="#s:formatting">Formatting Rules</a></li>
      <li><a href="#s:attributes">Attributes</a></li>
      <li><a href="#s:morehtml">More HTML</a></li>
      <li><a href="#s:reading">Reading Documents</a></li>
      <li><a href="#s:search">Finding Things in Documents</a></li>
      <li><a href="#s:creating">Creating Documents</a></li>
      <li><a href="#s:templating">A Better Way to Create Documents</a></li>
      <li><a href="#s:http">How the Web Works</a></li>
      <li><a href="#s:client">Getting Data</a></li>
      <li><a href="#s:server">Providing Data</a></li>
      <li><a href="#s:index">Creating an Index</a></li>
      <li><a href="#s:syndicate">Syndicating Data</a></li>
      <li><a href="#s:summary">Summing Up</a></li>
    </ol>

    <p>
      Carla Climate is studying climate change in the Northern and Southern hemispheres.
      As part of her work,
      she wants to see whether the gap between annual temperatures in Canada and Australia
      increased during the Twentieth Century.
      The raw data she needs is available online;
      her goal is to get it,
      do her calculations,
      and then post her results so that other scientists can use them.
    </p>

    <p>
      This chapter is about how she can do that.
      More specifically,
      it's about how to fetch data from the web,
      and how to create web pages that are useful to both human beings and computers.
      What we will <em>not</em> cover is how to build interactive web applications:
      our experience has shown that all we can do in the time we have
      is show you how to create security holes,
      which we're reluctant to do.
      However,
      everything in this chapter is a prerequisite for doing that,
      and there are lots of other good tutorials available
      if you decide that's what you really need.
      <!-- CC: Do you want to point people to where they might find these?-->
    </p>

    <section id="s:history">

      <h2>How We Got Here</h2>

      <div class="understand" id="u:history">
        <h3>Understand:</h3>
        <ul>
          <li>The difference between structured and unstructured data.</li>
          <li>The relationship between HTML and XML.</li>
        </ul>
      </div>

      <p>
        To start,
        let's have another look at the hearing tests from
        <a href="python.html">our chapter on Python programming</a>.
        Most people would probably store these results in a plain text file
        with one row for each test:
      </p>

<pre>
Date         Experimenter        Subject          Test       Score
----------   ------------        -------          -----      -----
2011-05-02   A. Binet            H. Ebbinghaus    DL-11      88%
2011-05-07   A. Binet            H. Ebbinghaus    DL-12      71%
2011-05-02   A. Binet            W. Wundt         DL-11      29%
2011-05-02   C. S. Pierce        W. Wundt         DL-11      45%
</pre>

      <p>
        This is pretty much what a conscientious researcher would write in a lab notebook,
        and is easy for a human being to read.
        It's a lot harder for a computer to understand, though.
        Any program that wanted to load this data
        would have to know that the first line of the file contains column titles,
        that the second can be ignored,
        that the first field of each row thereafter should be translated from text into a date,
        that the fields after that start in particular columns
        (since the number of spaces between them is variable,
        and the number of spaces inside names can also vary&mdash;compare
        "A.&nbsp;Binet" with "C.&nbsp;S.&nbsp;Pierce"),
        and so on.
        Such a program would not be hard to write,
        but having to write, debug, and maintain a separate program for each data set
        would be tedious.
      </p>

      <p>
        Now consider something a little less structured,
        like this quotation from Richard Feynman's 1965 Nobel Prize acceptance speech:
      </p>

      <blockquote>
        As a by-product of this same view,
        I received a telephone call one day at the graduate college at Princeton from Professor Wheeler,
        in which he said,
        "Feynman, I know why all electrons have the same charge and the same mass."
        "Why?"
        "Because, they are all the same electron!"
      </blockquote>

      <p>
        A lot of information is implicit in these four sentences,
        like the fact that "Wheeler" and "Feynman" are particular people,
        that "Princeton" is a place,
        that the speakers are alternating (with Wheeler speaking first),
        and so on.
        None of that is "visible" to a computer program,
        so if we had a database containing millions of documents
        and wanted to see which ones mentioned both John Wheeler
        (the physicist, not the geologist)
        and Princeton (the university, not the glacier),
        we might have to wade through a lot of false matches.
        What we need is some way to explicitly tell a computer
        all the things that human beings are able to infer.
      </p>

      <p>
        The first major effort to tackle this problem dates back to 1969,
        when Charles Goldfarb and others at IBM created
        the <a href="glossary.html#sgml">Standard Generalized Markup Language</a>, or SGML.
        It was designed as a way of adding extra data
        to medical and legal documents so that programs could search them more accurately.
        SGML was very complex (the specification is over 500 pages long),
        and unless you were a specialist,
        you probably didn't even know it existed:
        all you saw were the programs that used it.
      </p>

      <p>
        But in 1989 Tim Berners-Lee borrowed the syntax of SGML
        to create the <a href="glossary.html#html">HyperText Markup Language</a>, or HTML,
        for his new "World Wide Web".
        HTML looked superficially the same as SGML, but it was much (much) simpler:
        almost anyone could write it, so almost everyone did.
        However, HTML only had a small vocabulary,
        which users could not change or extend.
        They could say, "This is a paragraph," or, "This is a table,"
        but not, "This is a chemical formula," or, "This is a person's name."
      </p>

      <p>
        Instead of adding thousands of new terms for different application domains,
        a new standard for <em>defining</em> terms was created in 1998.
        This standard is called the
        <a href="glossary.html#xml">Extensible Markup Language</a> (XML);
        it's much more complex than HTML,
        but still simpler than SGML,
        and hundreds of specialized vocabularies have now been defined in terms of it.
      </p>

      <p class="fixme">make analogy between XML and defining functions</p>

      <p>
        More recently,
        a new version of HTML called HTML5 has been created.
        Web programmers are very excited about it,
        primarily because its new features allow them to create
        sophisticated user interfaces that run on smart phones and tablets as well as conventional computers.
        In what follows,
        though,
        we'll focus on some basics that haven't changed (much) in 20 years.
      </p>

      <div class="keypoints" id="k:history">
        <h3>Summary</h3>
        <ul>
          <li>Structured data is much easier for machines to process than unstructured data.</li>
          <li>Markup languages like HTML and XML can be used to add semantic information to text.</li>
        </ul>
      </div>

    </section>

    <section id="s:formatting">

      <h2>Formatting Rules</h2>

      <div class="understand" id="u:formatting">
        <h3>Understand:</h3>
        <ul>
          <li>How HTML elements are represented as text.</li>
          <li>That HTML elements must be nested to form a tree.</li>
        </ul>
      </div>

      <p>
        A basic HTML <a href="glossary.html#document">document</a>
        contains <a href="glossary.html#element">elements</a>
        and <a href="glossary.html#text">text</a>.
        (The full specification allows for many other things
        with names like "external entity references" and "processing instructions",
        but we'll ignore them.)
        The text in a document is just character data,
        and as far as HTML is concerned, it has no intrinsic meaning:
        "Feynman" is just seven characters,
        not a person.
      </p>

      <p>
        Elements are <a href="glossary.html#metadata">metadata</a>
        that describe the meaning of the document's content.
        For example,
        one element might indicate a heading,
        while another might signal that something is a cross-reference or a person's name.
      </p>

      <p>
        Elements are written using <a href="glossary.html#tag-xml">tags</a>,
        which must be enclosed in angle brackets <code>&lt;&hellip;&gt;</code>.
        For example, <code>&lt;cite&gt;</code> is used to mark the start of a citation,
        and <code>&lt;/cite&gt;</code> is used to mark its end.
        Elements must be properly nested:
        if an element called <code>inner</code> begins inside an element called <code>outer</code>,
        <code>inner</code> must end before <code>outer</code> ends.
        This means that <code>&lt;outer&gt;&hellip;&lt;inner&gt;&hellip;&lt;/inner&gt;&lt;/outer&gt;</code> is legal HTML,
        but <code>&lt;outer&gt;&hellip;&lt;inner&gt;&hellip;&lt;/outer&gt;&lt;/inner&gt;</code> is not.
      </p>

      <p>
        Here are some commonly-used HTML tags:
      </p>

      <table>
        <tr>
          <th>Tag</th>
          <th>Usage</th>
        </tr>
        <tr>
          <td><code>html</code></td>
          <td>Root element of entire HTML document.</td>
        </tr>
        <tr>
          <td><code>body</code></td>
          <td>Body of page (i.e., visible content).</td>
        </tr>
        <tr>
          <td><code>h1</code></td>
          <td>Top-level heading.  Use <code>h2</code>, <code>h3</code>, etc. for second- and third-level headings.</td>
        </tr>
        <tr>
          <td><code>p</code></td>
          <td>Paragraph.</td>
        </tr>
        <tr>
          <td><code>em</code></td>
          <td>Emphasized text.</td>
        </tr>
      </table>

      <p>
        Finally,
        every well-formed document started with a <code>DOCTYPE</code> declaration,
        which looks like:
      </p>

<pre>
&lt;!DOCTYPE html&gt;
</pre>

      <p class="continue">
        This tells programs what kind of elements are allowed to appear in the document:
        'html' (by far the most common case),
        'math' for MathML,
        and so on.
        Here is a simple HTML document that uses everything we've seen so far:
      </p>

      <p class="continue">

<pre>
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Dimorphism&lt;/h1&gt;&lt;p&gt;Occurring or existing in two different &lt;em&gt;forms&lt;/em&gt;.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;
</pre>

      <p>
        A web browser like Firefox might present this document as:
      </p>

      <figure id="f:very_simple">
        <img src="img/web/very_simple.png" alt="A Very Simple Web Page" />
      </figure>

      <p class="continue">
        Other devices will display it differently.
        A phone,
        for example,
        might use a different background color for the heading,
        while a screen reader for someone with visual disabilities would read the text aloud.
      </p>

      <p>
        These different presentations are possible because
        HTML separates content from presentation,
        or in computer science jargon,
        separates <a href="glossary.html#model">models</a> from <a href="glossary.html#view">views</a>.
        The model is the data itself;
        the view is how that data is displayed,
        such as a particular pattern of pixels on our screen
        or a particular sequence of sounds on our headphones.
        A given model may be viewed in many different ways,
        just as what files are on your hard drive
        can be viewed as a list,
        as snapshots,
        or as a hierarchical tree
        (<a href="#f:filesystem_views">Figure XXX</a>).
      </p>

      <figure id="f:filesystem_views">
        <img src="img/web/filesystem_views.png" alt="Different Views of a File System" />
      </figure>

      <p>
        People can construct models from views almost effortlessly&mdash;if you are able to read,
        it's almost impossible <em>not</em> to see the letters "HTML"
        in the following block of text:
      </p>

<pre>
*   *  *****  *   *  *
*   *    *    ** **  *
*****    *    * * *  *
*   *    *    *   *  *
*   *    *    *   *  ****
</pre>

      <p class="continue">
        Computers,
        on the other hand,
        are very bad at reconstructing models from views.
        In fact,
        many of the things we do without apparent effort,
        like understanding sentences,
        are still open research problems in computer science.
        That's why markup languages were invented:
        they allow us to explicitly specify the "what" that we infer so easily
        for computers' benefit.
      </p>

      <p>
        There are a couple of other formatting rules we need to know
        in order to create and understand documents.
        If we are writing HTML by hand
        instead of using a <a href="glossary.html#wysiwyg">WYSIWYG</a> editor
        like LibreOffice or Microsoft Word,
        we might lay it out like this to make it easier to read:
      </p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
<span class="highlight">  </span>&lt;body&gt;
<span class="highlight">    </span>&lt;h1&gt;Dimorphism&lt;/h1&gt;
<span class="highlight">    </span>&lt;p&gt;Occurring or existing in two different &lt;em&gt;forms&lt;/em&gt;.&lt;/p&gt;
<span class="highlight">  </span>&lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        Doing this doesn't change how most browsers render the document,
        since they usually ignore "extra" whitespace
        (highlighted above).
        <span class="fixme">refer back to 'highlight' later when talking about CSS and semantic separation</span>
        As we'll see when we start writing programs of our own, though,
        that whitespace doesn't magically disappear when a program reads the document in,
        so at some point we have to decide what to do with it.
      </p>

      <p>
        Second,
        we must use <a href="glossary.html#escape-sequence">escape sequences</a>
        to represent the special characters <code>&lt;</code> and <code>&gt;</code>
        for the same reason that we have to use <code>\&quot;</code>
        inside a double-quoted string in a program.
        <span class="fixme">where do we explain escape sequences?</span>
        In HTML and XML,
        an escape sequence is an ampersand '&amp;'
        followed by the abbreviated name of the character
        (such as 'amp' for "ampersand")
        and a semi-colon.
        The four most common escape sequences are:
      </p>

      <table>
        <tr>
          <th>Sequence</th>
          <th>Character</th>
        </tr>
        <tr>
          <td><code>&amp;lt;</code></td>
          <td><code>&lt;</code></td>
        </tr>
        <tr>
          <td><code>&amp;gt;</code></td>
          <td><code>&gt;</code></td>
        </tr>
        <tr>
          <td><code>&amp;quot;</code></td>
          <td><code>&quot;</code></td>
        </tr>
        <tr>
          <td><code>&amp;amp;</code></td>
          <td><code>&amp;</code></td>
        </tr>
      </table>

      <p>
        One final formatting rule is that
        every document must have a single <a href="glossary.html#root-element">root element</a>,
        i.e., a single element must enclose everything else.
        When combined with the rule that elements must be properly nested,
        this means that every document can be thought of as a <a href="glossary.html#tree">tree</a>.
        For example,
        we could draw the logical structure of our little document
        as shown in <a href="#f:very_simple_tree">Figure XXX</a>.
      </p>

      <figure id="f:very_simple_tree">
        <img src="img/web/very_simple_tree.png" alt="Tree View of a Very Simple Web Page" />
      </figure>

      <p>
        A document like this, on the other hand, is not strictly legal:
      </p>

<pre>
&lt;h1&gt;Dimorphism&lt;/h1&gt;
&lt;p&gt;Occurring or existing in two different &lt;em&gt;forms&lt;/em&gt;.&lt;/p&gt;
</pre>

      <p class="continue">
        because it has two top-level elements
        (the <code>h1</code> and the <code>p</code>).
        Most browsers will render it correctly,
        since they're designed to accommodate improperly-formatted HTML,
        but most programs won't,
        because they're not.
        <span class="fixme">mention BeautifulSoup?</span>
      </p>

      <div class="keypoints" id="k:formatting">
        <h3>Summary</h3>
        <ul>
          <li>HTML documents contain elements and text.</li>
          <li>Elements are represented using tags.</li>
          <li>Different devices may display HTML differently.</li>
          <li>Every document must have a single root element.</li>
          <li>Tags must be properly nested to form a tree.</li>
          <li>Special characters must be written using escape sequences beginning with &amp;.</li>
        </ul>
      </div>

    </section>

    <section id="s:attributes">

      <h2>Attributes</h2>

      <div class="understand" id="u:attributes">
        <h3>Understand:</h3>
        <ul>
          <li>How to customize elements with attributes.</li>
          <li>When to use attributes rather than nested elements.</li>
        </ul>
      </div>

      <p>
        Elements can be customized by giving them <a href="glossary.html#attribute">attributes</a>.
        These are name/value pairs enclosed in the opening tag like this:
      </p>

<pre>
&lt;h1 align="center"&gt;A Centered Heading&lt;/h1&gt;
</pre>

      <p class="continue">
        or:
      </p>

<pre>
&lt;p class="disclaimer"&gt;This planet provided as-is.&lt;/p&gt;
</pre>

      <p>
        Any particular attribute name may appear at most once in any element,
        just like keys may be present at most once in a <a href="setdict.html#s:dict">dictionary</a>,
        so <code>&lt;p align="left" align="right"&gt;&hellip;&lt;/p&gt;</code> is illegal.
        Attributes' values <em>must</em> be in quotes in XML;
        HTML5 allows single-word values to be unquoted,
        but quoting is still recommended.
      </p>

      <p>
        Another similarity between attributes and dictionaries is that
        attributes are unordered.
        They have to be <em>written</em> in some order,
        just as the keys and values in a dictionary have to be displayed in some order when they are printed,
        but as far as the rules of HTML are concerned,
        the elements:
      </p>

<pre>
&lt;p align="center" class="disclaimer"&gt;This web page is made from 100% recycled pixels.&lt;/p&gt;
</pre>

      <p class="continue">
        and:
      </p>

<pre>
&lt;p class="disclaimer" align="center"&gt;This web page is made from 100% recycled pixels.&lt;/p&gt;
</pre>

      <p class="continue">
        mean the same thing.
      </p>

      <div class="box">
        <h3>Attributes vs. Nested Elements</h3>

        <p>
          When should we use attributes, and when should we nest elements?
          As a general rule,
          we should use attributes when:
        </p>

        <ul>

          <li>
            each value can occur at most once for any element;
          </li>

          <li>
            the order of the values doesn't matter; and
          </li>

          <li>
            those values have no internal structure,
            i.e.,
            we will never need to parse an attribute's value
            in order to understand it.
          </li>

        </ul>

        <p class="continue">
          In all other cases, we should use nested elements.
          However, many widely-used XML formats break these rules
          in order to make it easier for people to write XML by hand.
          For example,
          in the Scalable Vector Graphics (SVG) format used to describe images as XML,
          we would define a rectangle as follows:
        </p>

<pre>
&lt;rect width="300" height="100" style="fill:rgb(0,0,255); stroke-width:1; stroke:rgb(0,0,0)"/&gt;
</pre>

        <p class="continue">
          In order to understand the <code>style</code> attribute,
          a program has to somehow know to split it on semicolons,
          and then to split each piece on colons.
          This means that general-purpose programs for handling XML
          can't extract all the information that's implicit in SVG,
          which partly defeats the purpose of using XML in the first place.
          <span class="fixme">compare to database rules: no internal structure in columns</span>
        </p>

      </div>

      <div class="keypoints" id="k:attributes">
        <h3>Summary</h3>
        <ul>
          <li>Elements can be customized by adding key-value pairs called attributes.</li>
          <li>An element's attributes must be unique, and are unordered.</li>
          <li>Attribute values should not have any internal structure.</li>
        </ul>
      </div>

    </section>

    <section id="s:morehtml">

      <h2>More HTML</h2>

      <div class="understand" id="u:morehtml">
        <h3>Understand:</h3>
        <ul>
          <li>How to add lists, tables, images, and links to HTML.</li>
          <li>That metadata should go in the document's head.</li>
        </ul>
      </div>

      <p>
        As anyone who has surfed the web has seen,
        web pages can contain a lot more than just headings and paragraphs.
        To start with,
        HTML provides two kinds of lists:
        <code>ul</code> to mark an unordered (bulleted) list,
        and <code>ol</code> for an ordered (numbered) one.
        Items inside either kind of list must be wrapped in <code>li</code> elements:
      </p>

<pre src="src/web/nested_lists.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;ul&gt;
      &lt;li&gt;A. Binet
        &lt;ol&gt;
          &lt;li&gt;H. Ebbinghaus&lt;/li&gt;
          &lt;li&gt;W. Wundt&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;C. S. Pierce
        &lt;ol&gt;
          &lt;li&gt;W. Wundt&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <figure id="f:nested_lists">
        <img src="img/web/nested_lists.png" alt="Nested Lists"/>
      </figure>

      <p class="continue">
        Note how elements are nested:
        since the ordered lists "belong" to the unordered list items above them,
        they are inside those items' <code>&lt;li&gt;&hellip;&lt;/li&gt;</code> tags.
        And remember,
        the indentation used to make this list easier for people to read
        means nothing to the computer:
        we could put the whole thing on one line,
        or write it as:
      </p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;ul&gt;
    &lt;li&gt;A. Binet
  &lt;ol&gt;
    &lt;li&gt;H. Ebbinghaus&lt;/li&gt;
    &lt;li&gt;W. Wundt&lt;/li&gt;
  &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;C. S. Pierce
  &lt;ol&gt;
    &lt;li&gt;W. Wundt&lt;/li&gt;
  &lt;/ol&gt;
    &lt;/li&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        and the computer would interpret and display it the same way.
        A human being,
        on the other hand,
        would find the inconsistent indentation of the second layout
        much harder to follow.
      </p>

      <p>
        HTML also provides tables, but they are awkward to use:
        tables are naturally two-dimensional,
        but text is one-dimensional.
        This is exactly like the problem of representing a two-dimensional array in memory,
        and we solve it in the same way:
        by writing down the rows,
        and the columns within each row,
        in a fixed order.
        <span class="fixme">link back to dev.html and numpy.html</span>
        The <code>table</code> element marks the table itself;
        within that,
        each row is wrapped in <code>tr</code> (for "table row"),
        and within those,
        column items are wrapped in <code>th</code> (for "table heading")
        or <code>td</code> (for "table data"):
      </p>

<pre src="src/web/simple_table.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;&lt;/th&gt;
        &lt;th&gt;A. Binet&lt;/th&gt;
        &lt;th&gt;C. S. Pierce&lt;/th&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;H. Ebbinghaus&lt;/th&gt;
        &lt;td&gt;88%&lt;/td&gt;
        &lt;td&gt;NA&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;th&gt;W. Wundt&lt;/th&gt;
        &lt;td&gt;29%&lt;/td&gt;
        &lt;td&gt;45%&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <figure id="f:simple_table">
        <img src="img/web/simple_table.png" alt="A Simple Table" />
      </figure>

      <div class="box">
        <h3>Tables and Multi-Column Layout</h3>

        <p>
          Tables are sometimes used to do multi-column layout,
          as well as for tabular data,
          but this is a bad idea.
          To understand why,
          consider two other HTML tags:
          <code>i</code>, meaning "italics",
          and <code>em</code>, meaning "emphasis".
          The former directly controls how text is displayed,
          but by doing so,
          it breaks the separation between model and view that is the heart of markup's usefulness.
          Without understanding the text that has been italicized,
          a program cannot understand whether it is meant to indicate someone shouting,
          the definition of a new term,
          or the title of a book.
          The <code>em</code> tag, on the other hand, has exactly one meaning,
          and that meaning is different from the meaning of <code>dfn</code> (a definition)
          or <code>cite</code> (a citation).
        </p>

        <p>
          Similarly,
          <span class="fixme">finish the thought...</span>
        </p>

      </div>

      <p>
        HTML pages can also contain images.
        (In fact,
        the World Wide Web didn't really take off until
        the Mosaic browser allowed people to mix images with text.)
        The word "contain" is misleading, though:
        HTML documents can only contain text,
        so we cannot store an image "in" a page.
        Instead,
        we must put it in some other file,
        and insert a reference to that file in the HTML using the <code>img</code> tag.
        Its <code>src</code> attribute specifies where to find the image file;
        this can be a path to a file on the same host as the web page,
        or a URL for something stored elsewhere.
        For example,
        when a browser displays this:
      </p>

<pre src="src/web/simple_image.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;My daughter's first online chat:&lt;/p&gt;
    &lt;img src="madeleine.jpg"/&gt;
    &lt;p&gt;but probably not her last.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        it looks for the file <code>madeleine.jpg</code>
        in the same directory as the HTML file:
      </p>

      <figure id="f:simple_image">
        <img src="img/web/simple_image.png" alt="Simple Images" />
      </figure>

      <p>
        Notice,
        by the way,
        that the <code>img</code> element is written as
        <code>&lt;img&hellip;/&gt;</code>,
        i.e.,
        with a trailing slash inside the <code>&lt;&gt;</code>
        rather than with a separate closing tag.
        This makes sense because the element doesn't contain any text:
        the content is referred to by its <code>src</code> attribute.
        Any element that doesn't contain anything
        can be written using this short form.
      </p>

      <p>
        Images don't have to be in the same directory as the pages that refer to them.
        When the browser displays this:
      </p>

<pre src="src/web/image_with_path.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;Yes, she knows she's cute:&lt;/p&gt;
    &lt;img src="img/cute-smile.jpg"/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        it looks in the directory containing the page
        for a sub-directory called <code>img</code>,
        and loads the image file from there,
        while if it's given:
      </p>

<pre src="src/web/image_with_url.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;img src="http://software-carpentry.org/img/software-carpentry-logo.png"/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        it downloads the image from the URL
        <code>http://software-carpentry.org/img/software-carpentry-logo.png</code>
        and displays that.
      </p>

      <p>
        Whenever we refer to an image,
        we should use the <code>img</code> tag's <code>alt</code> attribute
        to provide a title or description of the image.
        This is what screen readers for people with visual handicaps will say aloud to "display" the image;
        it's also what search engines use to classify images
        so that people can find them.
        Adding this to our previous example gives:
      </p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;My daughter's first online chat:&lt;/p&gt;
    &lt;img src="madeleine.jpg" <span class="highlight">alt="Madeleine's first online chat"</span>/&gt;
    &lt;p&gt;but probably not her last.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        The most important use of URLs in documents is
        to create the links within and between pages that make HTML "hypertext".
        We create links using the <code>a</code> element.
        Whatever is inside the element is displayed and (usually) underlined for clicking;
        this is usually a few words text,
        but it can also be an entire paragraph,
        a table,
        or an image.
      </p>

      <p>
        The <code>a</code> element's <code>href</code> attribute
        specifies what the link is pointing at;
        as with images,
        this can be either a local filename or a URL.
        For example,
        we can create a listing of the examples we've written so far like this:
      </p>

<pre src="src/web/simple_listing.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;p&gt;
      Simple HTML examples for
      &lt;a href="http://software-carpentry.org"&gt;Software Carpentry&lt;/a&gt;.
    &lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;&lt;a href="very-simple.html"&gt;a very simple page&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="hide-paragraph.html"&gt;hiding paragraphs&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="nested-lists.html"&gt;nested lists&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="simple-table.html"&gt;a simple table&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href="simple-image.html"&gt;a simple image&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <figure id="f:simple_listing">
        <img src="img/web/simple_listing.png" alt="Using Hyperlinks" />
      </figure>

      <p>
        The hyperlink element is called <code>a</code> because
        it can also used to create <a href="glossary.html#anchor">anchors</a> in documents
        by giving them a <code>name</code> attribute instead of an <code>href</code>.
        An anchor is simply a location in a document that can be linked to.
        For example,
        suppose we formatted the Feynman quotation given earlier like this:
      </p>

<pre>
&lt;blockquote&gt;
  As a by-product of this same view, I received a telephone call one day
  at the graduate college at &lt;a name="pu"&gt;Princeton&lt;/a&gt;
  from Professor Wheeler, in which he said,
  "Feynman, I know why all electrons have the same charge and the same mass."
  "Why?"
  "Because, they are all the same electron!"
&lt;/blockquote&gt;
</pre>

      <p class="continue">
        If this quotation was in a file called <code>quote.html</code>,
        we could then create a hyperlink directly to the mention of Princeton
        using <code>&lt;a&nbsp;href="quote.html#pu"&gt;</code>.
        The <code>#</code> in the <code>href</code>'s value separates the path to the document
        from the anchor we're linking to.
        Inside <code>quote.html</code> itself,
        we could link to that same location simply using
        <code>&lt;a&nbsp;href="#pu"&gt;</code>.
      </p>

      <p>
        Using the <code>a</code> element for both links and targets was poor design&mdash;programs
        are simpler to write if each element has one purpose, and one alone&mdash;but
        we're stuck with it now.
        A more modern way to create anchors is to add an <code>id</code> attribute
        to some other element.
        For example,
        if we wanted to be able to link to the quotation itself,
        we could write:
      </p>

<pre>
&lt;blockquote <span class="highlight">id="wheeler-electron-quote"</span>&gt;
  As a by-product of this same view, I received a telephone call one day
  at the graduate college at &lt;a name="pu"&gt;Princeton&lt;/a&gt;
  from Professor Wheeler, in which he said,
  "Feynman, I know why all electrons have the same charge and the same mass."
  "Why?"
  "Because, they are all the same electron!"
&lt;/blockquote&gt;
</pre>

      <p class="continue">
        and then refer to <code>quote.html#wheeler-electron-quote</code>.
      </p>

      <p>
        Finally,
        well-written HTML pages have a <code>head</code> element as well as a <code>body</code>.
        The head isn't displayed;
        instead,
        it's used to store metadata about the page as a whole.
        The most common element inside <code>head</code> is <code>title</code>,
        which,
        as its name suggests,
        gives the page's title.
        (This is usually displayed in the browser's title bar.)
        Another common item is <code>meta</code>,
        whose two attributes <code>name</code> and <code>content</code>
        allow authors to embed arbitrary information in their pages.
        If we add these to the web page we wrote earlier,
        we might have:
      </p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Dimorphism Defined&lt;title&gt;
    &lt;meta name="author" content="Alan Turing"/&gt;
    &lt;meta name="institution" content="Euphoric State University"/&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Dimorphism&lt;/h1&gt;
    &lt;p&gt;Occurring or existing in two different &lt;em&gt;forms&lt;/em&gt;.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p id="p:hide-paragraph">
        Well-written pages also use comments (just like code),
        which start with <code>&lt;!--</code> and end with <code>--&gt;</code>.
      </p>

      <div class="box">

        <h3>Hiding Content</h3>

        <p>
          Commenting out part of a page does <em>not</em> hide the content
          from people who really want to see it:
          while a browser won't display what's inside a comment,
          it's still in the page,
          and anyone who uses "View Source" can read it.
          For example,
          if you are looking at this page in a web browser right now,
          try viewing the source
          and searching for the word "Surprise".
        </p>

        <!-- Surprise: this isn't displayed by the browser, but is still in the document. -->

        <p>
          If you really don't want people to be able to read something,
          the only safe thing to do is to keep it off the web.
        </p>

      </div>

      <div class="keypoints" id="k:morehtml">
        <h3>Summary</h3>
        <ul>
          <li>Put metadata in <code>meta</code> elements in a page's <code>head</code> element.</li>
          <li>Use <code>ul</code> for unordered lists and <code>ol</code> for ordered lists.</li>
          <li>Add comments to pages using <code>&lt;!--</code> and <code>--&gt;</code>.</li>
          <li>Use <code>table</code> for tables, with <code>tr</code> for rows and <code>td</code> for values.</li>
          <li>Use <code>img</code> for images.</li>
          <li>Use <code>a</code> to create hyperlinks.</li>
          <li>Give elements a unique <code>id</code> attribute to link to it.</li>
        </ul>
      </div>

    </section>

    <section id="s:reading">

      <h2>Reading Documents</h2>

      <div class="understand" id="u:reading">
        <h3>Understand:</h3>
        <ul>
          <li>How the Document Object Model represents HTML and XML.</li>
        </ul>
      </div>

      <p>
        People usually write their home pages by hand,
        but most pages that display lists of experimental results,
        or second-hand lab equipment for sale,
        are created by programs.
        For historical reasons,
        Python's standard library includes several libraries that process XML (including HTML);
        we'll use the simplest one,
        called <code>ElementTree</code>,
        but you will often run into programs that use others.
      </p>

      <p>
        Most of these libraries represent the nested structure of XML using something called
        the <a href="glossary.html#document-object-model">Document Object Model</a> (DOM).
        This stores the document as a <a href="glossary.html#tree">tree</a>
        with one node for each element or block of text.
        The root element of the document,
        such as the all-enclosing <code>html</code> in a web page,
        is the root node of the tree.
        Every other element or block of text is a child of it,
        or a child of a child,
        and so on.
        For example,
        the tree representing our web page about dimorphism
        looks like <a href="#f:dimorphism_tree">Figure XXX</a>.
      </p>

      <figure id="f:dimorphism_tree">
        <img src="img/web/dimorphism_tree.png" alt="Tree Representation of Dimorphism Page" />
      </figure>

      <p>
        There are basically two ways to create a tree like this:
        parse a string (or file) containing XML,
        or build the nodes one by one and put them together manually.
        The former is more common,
        since the usual way to store and exchange XML or HTML is as text,
        so we will explore that first.
        Let's begin by turning text into HTML and then back into text:
      </p>

<pre src="src/web/parse_simple_page.py">
import xml.etree.ElementTree as ET

page = '''&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Dimorphism&lt;/h1&gt;
    &lt;p class="definition"&gt;Occurring or existing in two different &lt;u&gt;forms&lt;/u&gt;.&lt;/p&gt;
    &lt;p&gt;
      The most notable form is sexual dimorphism,
      in which males and females have noticeably different appearances.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;'''

doc = ET.fromstring(page)
text = ET.tostring(doc, 'utf-8')
print text
</pre>

      <p class="continue">
        We start by importing the <code>xml.etree.ElementTree</code> library
        and giving it the alias <code>ET</code>
        (which is a lot easier to type and read).
        The multi-line string assigned to the variable <code>page</code>
        is the "document" we will parse;
        most real programs will read data from a file instead.
      </p>

      <p>
        Parsing itself takes just a single call to <code>ET.fromstring</code>;
        it returns the root node of the DOM tree corresponding to that document.
        We then convert that tree back to text by calling <code>ET.tostring</code>.
        The <code>'utf-8'</code> argument specifies how we want characters represented;
        you should always use this option unless you know enough to know
        that you want something else.
        <span class="fixme">need a better explanation than this</span>
      </p>

      <p>
        The program's output is:
      </p>

<pre><span class="out">&lt;html&gt;
  &lt;body&gt;
    &lt;h1&gt;Dimorphism&lt;/h1&gt;
    &lt;p class="definition"&gt;Occurring or existing in two different &lt;u&gt;forms&lt;/u&gt;.&lt;/p&gt;
    &lt;p&gt;
      The most notable form is sexual dimorphism,
      in which males and females have noticeably different appearances.
    &lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</span>
</pre>

      <p class="continue">
        which is exactly what we started with.
      </p>

      <p class="fixme">point out how much simpler this is than parsing...</p>

      <p>
        In the example above,
        our output was exactly the same as our input,
        but that won't always be the case.
        Here's another simple program that converts text to a node tree and back:
      </p>

<pre src="src/web/round_trip.py">
import xml.etree.ElementTree as ET

original = '''&lt;root&gt;&lt;node
                     front="1"
                     back="2"&gt;content&lt;/node&gt;&lt;/root&gt;'''


doc = ET.fromstring(original)
print ET.tostring(doc, 'utf-8')
<span class="out">&lt;root&gt;&lt;node back="2" front="1"&gt;content&lt;/node&gt;&lt;/root&gt;</span>
</pre>

      <p class="continue">
        <code>node</code>'s attributes are all on one line in the output,
        and in a different order than they were in the input.
        The reason for the first difference is that XML ignores whitespace inside elements:
        the parser simply throws away
        the extra spaces and newlines inside the definition of <code>&lt;node&hellip;&gt;</code>.
        The reason for the second is that attributes are treated as a dictionary,
        and dictionary keys are unordered.
        As far as the rules of XML are concerned,
        the input and output are the same thing.
        Unfortunately,
        as far as string comparison and tools like <code>diff</code> are concerned,
        they are not.
      </p>

      <p>
        Since almost all XML or HTML documents are stored in files,
        the ElementTree library provides a convenience function
        that parses files directly.
        If <code>dimorphism.html</code> contains our definition of sexual dimorphism,
        then:
      </p>

<pre>
import xml.etree.ElementTree as ET
doc = ET.parse('dimorphism.html')
</pre>

      <p class="continue">
        reads the text in that file,
        converts it to a DOM tree,
        and returns the tree's root node.
      </p>

      <div class="keypoints" id="k:reading">
        <h3>Summary</h3>
        <ul>
          <li>Use <code>xml.etree.ElementTree</code> to parse HTML and XML.</li>
        </ul>
      </div>

    </section>

    <section id="s:search">

      <h2>Finding Nodes</h2>

      <div class="understand" id="u:search">
        <h3>Understand:</h3>
        <ul>
          <li>How to find DOM elements using XPath.</li>
        </ul>
      </div>

      <p>
        Most databases are read more often than they're written,
        so most of <a href="db.html">our discussion of SQL</a>
        focuses on finding things.
        Most web pages are read more than once too,
        so libraries like ElementTree provide tools for locating nodes of interest.
        The most important of these is the <code>findall</code> method,
        which searches all the children of a node
        to find ones that match a pattern.
        For example,
        if some molecular formulas are stored like this:
      </p>

<pre src="src/web/molecular_formulas.xml">
&lt;formulas&gt;
  &lt;formula name="ammonia"&gt;
    &lt;atom symbol="N" number="1"/&gt;
    &lt;atom symbol="H" number="3"/&gt;
  &lt;/formula&gt;
  &lt;formula name="water"&gt;
    &lt;atom symbol="H" number="2"/&gt;
    &lt;atom symbol="O" number="1"/&gt;
  &lt;/formula&gt;
  &lt;formula name="methanol"&gt;
    &lt;atom symbol="C" number="1"/&gt;
    &lt;atom symbol="O" number="1"/&gt;
    &lt;atom symbol="H" number="4"/&gt;
  &lt;/formula&gt;
&lt;/formulas&gt;
</pre>

      <p class="continue">
        then this program will count how many formulas there are:
      </p>

<pre src="src/web/count_formulas.py">
import sys
import xml.etree.ElementTree as ET

doc = ET.parse(sys.argv[1])
root = doc.getroot()
formulas = root.findall("./formula")
print len(formulas)
<span class="out">3</span>
</pre>

      <p>
        The key to this programs is <code>root.findall("./formula")</code>.
        The pattern <code>"./formula"</code> means,
        "Starting with this node ('.'),
        examine its children ('/')
        for elements with the tag 'formula."
        The result of the <code>findall</code> call is a list of nodes that match.
      </p>

      <p>
        The mini-language used for patterns is called
        <a href="glossary.html#xpath">XPath</a>.
        Some parts,
        like '.' and '/',
        are deliberately reminiscent of the way paths are described in
        <a href="shell.html#s:filedir">the Unix filesystem</a>.
        Other parts are more complicated,
        but it's possible to do a lot without using them.
        Some common XPath expressions are:
      </p>

      <table>
        <tr>
          <td>
            <code>tag</code>
          </td>
          <td>
            All immediate children with the given tag.
            <code>formula</code> selects all child <code>formula</code> elements,
            and <code>formula/atom</code> selects all <code>atom</code> elements
            that are children of <code>formula</code> children.
          </td>
        </tr>
        <tr>
          <td>
            <code>*</code>
          </td>
          <td>
            All child elements.
            <code>*/atom</code> selects all grandchild <code>atom</code> elements,
            regardless of what the intervening parent is.
          </td>
        </tr>
        <tr>
          <td>//</td>
          <td>
            All subelements on all levels beneath the current element.
            <code>.//atom</code> selects all <code>atoms</code> elements in the entire tree.
          </td>
        </tr>
        <tr>
          <td><code>.</code></td>
          <td>
            The current node.
            It is mostly used at the beginning of a path to indicate that it is a relative path.
          </td>
        </tr>
        <tr>
          <td><code>..</code></td>
          <td>The parent of the current node.</td>
        </tr>
        <tr>
          <td><code>[@attrib]</code></td>
          <td>
            All elements with the given attribute (regardless of that attribute's value).
            <code>.//atom[@name]</code> selects all atoms in the tree
            that have a <code>name</code> attribute,
            but not any <code>atom</code> elements that are missing that attribute.
          </td>
        </tr>
        <tr>
          <td>
            <code>[@attrib="value"]</code>
          </td>
          <td>
            All elements for which the given attribute has the given value.
            <code>.//atom[@symbol="C"]</code> finds all carbon atoms.
          </td>
        </tr>
        <tr>
          <td>
            <code>[tag]</code>
          </td>
          <td>
            All elements that have a child element with the given tag.
            <code>atom[comment]</code> finds all <code>atom</code> nodes
            that have an immediate child of type <code>comment</code>.
          </td>
        </tr>
        <tr>
          <td>
            <code>[position]</code>
          </td>
          <td>
            All elements that located in the given position relative to their parent.
            The position can be either an integer (1 is the first position),
            the expression <code>last()</code> for the last position,
            or a position relative to <code>last()</code>,
            such as <code>last()-1</code>.
          </td>
        </tr>
      </table>

      <p>
        Let's use these expressions to check that a data file is properly formatted
        by looking for all the <code>atom</code> nodes
        that are <em>not</em> immediate children of <code>formula</code> nodes.
        Our data file is:
      </p>

<pre src="src/web/bad_formulas.xml">
&lt;formulas&gt;
  &lt;formula name="ammonia"&gt;
    &lt;atom symbol="N" number="1"/&gt;
    &lt;atom symbol="H" number="3"/&gt;
  &lt;/formula&gt;
  &lt;atom symbol="H" number="2"/&gt;       <span class="comment">&lt;!-- mistake! --&gt;</span>
  &lt;formula name="water"&gt;
    &lt;atom symbol="O" number="1"&gt;
      &lt;atom symbol="H" number="2"/&gt;   <span class="comment">&lt;!-- another mistake --&gt;</span>
    &lt;/atom&gt;
  &lt;/formula&gt;
&lt;/formulas&gt;
</pre>

      <p class="continue">
        and our program is:
      </p>

<pre src="src/web/validate_doc.py">
import xml.etree.ElementTree as ET

doc = ET.parse('bad_formulas.xml')
all_atoms = doc.findall('.//atom')
proper_atoms = doc.findall('.//formula/atom')
wrongly_placed = set(all_atoms) - set(proper_atoms)
for atom in wrongly_placed:
    print ET.tostring(atom)
<span class="out">&lt;atom number="2" symbol="H" /&gt;

&lt;atom number="2" symbol="H" /&gt;

</span>
</pre>

      <p class="continue">
        After converting the XML document to a tree,
        this program uses <code>doc.findall</code> to get all of the <code>atom</code> nodes,
        and then uses it again to find all the <code>atom</code> nodes
        that are immediate children of <code>formula</code> nodes.
        Subtracting the second set from the first
        gives the nodes that are <em>not</em> immediate children of <code>formula</code> nodes,
        i.e.,
        that are in the wrong place.
      </p>

      <p>
        A couple of things are worth pointing out about this program.
        First,
        the ElementTree library doesn't record where in the document nodes are from,
        so we can't pinpoint the line or character position of the offending nodes.
        Second,
        the double-spacing on the output comes from the fact that
        our original document contained lots of whitespace
        to make it easier for human beings to read,
        and ElementTree kept this whitespace
        (storing it as the <code>tail</code> value for various nodes).
        This kind of extra whitespace is always an annoyance when we're programming,
        so it's tempting to leave it out.
        However,
        doing so makes it harder for human beings to read the raw XML
        using line-oriented editors.
        Most modern browsers will display the XML as a tree
        (<a href="#f:xml_in_browser">Figure XXX</a>)
        but native XML-oriented editing tools are still clumsy.
      </p>

      <figure id="f:xml_in_browser">
        <img src="img/web/xml_in_browser.png" alt="XML in the Browser" />
      </figure>

      <div class="keypoints" id="k:search">
        <h3>Summary</h3>
        <ul>
          <li>Use XPath expressions to identify nodes in a document.</li>
          <li>Use a node's <code>findall</code> method to find children matching an XPath expression.</li>
        </ul>
      </div>

    </section>

    <section id="s:creating">

      <h2>Creating Documents</h2>

      <div class="understand" id="u:creating">
        <h3>Understand:</h3>
        <ul>
          <li>How to create DOM in memory and turn it into a document.</li>
        </ul>
      </div>

      <p>
        So much for reading XML: how do we create it?
        Let's start by writing a program that re-creates our dimorphism page
        one element at time:
      </p>

<pre src="src/web/build_simple_page.py">
import xml.etree.ElementTree as ET

root = ET.Element('html')

body = ET.Element('body')
root.append(body)

title = ET.SubElement(body, 'h1')
title.text = 'Dimorphism'

p1 = ET.SubElement(body, 'p')
p1.text = 'Occurring or existing in two different '
u = ET.SubElement(p1, 'u')
u.text = 'forms'
p1.tail = '.'

long_text = '''The most notable form is sexual dimorphism,
in which males and females have noticeably different appearances.'''
ET.SubElement(body, 'p').text = long_text

print ET.tostring(root)
</pre>

      <p>
        There is much less to this program than first appears.
        It starts by creating an object of type <code>Element</code>,
        which is the class the ElementTree library uses to represent nodes.
        The argument to <code>Element</code>'s constructor,
        <code>html</code>,
        specifies the element's type.
      </p>

      <p>
        The next two lines create another node of type <code>body</code>
        and then append that to the root node.
        At this point, our tree looks like
        <a href="#f:partial_tree">Figure XXX</a>:
      </p>

      <figure id="f:partial_tree">
        <img src="img/web/partial_tree.png" alt="Partially-Constructed Tree" />
      </figure>

      <p>
        The rest of the program does little more than create and append nodes.
        Because creating a node and appending it to another one is so common,
        ElementTree provides a convenience function called <code>SubElement</code>
        which combines the two steps.
        The two lines:
      </p>

<pre>
title = ET.SubElement(body, 'h1')
title.text = 'Dimorphism'
</pre>

      <p class="continue">
        create a new node of type <code>h1</code>,
        append it to the <code>body</code> node,
        and then set the text content of the title node to be the string <code>'Dimorphism'</code>.
      </p>

      <p>
        The next step is the most complicated.
        We need to create a paragraph node
        whose <code>class</code> attribute has the value <code>definition</code>,
        and which contains three things:
      </p>

      <ol>

        <li>
          the text <code>'Occurring or existing in two different&nbsp;'</code>
          (with a space at the end);
        </li>

        <li>
          a <code>u</code> element containing the text <code>'forms'</code>;
          and
        </li>

        <li>
          another piece of text containing the period '.' that ends the sentence.
        </li>

      </ol>

      <p>
        Creating the paragraph node and appending it to our body node is easy:
        we just call <code>SubElement</code>.
        Setting an attribute is also easy:
        every node has a dictionary called <code>attrib</code>
        whose keys are attribute names
        and whose values are those attributes' values.
        The single line:
      </p>

<pre>
p1.attrib['class'] = 'definition'
</pre>

      <p class="continue">
        therefore creates the attribute we want.
      </p>

      <p>
        Now for the paragraph's content.
        Again, the first part is easy:
        we just set <code>p1.text</code>.
        And underlining the word "forms" is easy too:
        we create a node of type <code>u</code> and append it to the paragraph.
        But where should the closing period be stored?
      </p>

      <p>
        Along with <code>text</code>,
        ElementTree nodes have another text field called <code>tail</code>,
        which stores the text <em>after</em> the node
        but before the start of anything else.
        Since the period is in the paragraph,
        the right place to store it is therefore <code>u.tail</code>
        (since putting it in <code>p1.tail</code> would imply that
        it came after the end of the first paragraph,
        but before the start of the next paragraph).
      </p>

      <p>
        Finally,
        we create the second paragraph that elaborates dimorphism's definition
        by combining node creation and text setting in a single line:
      </p>

<pre>
ET.SubElement(body, 'p').text = long_text
</pre>

      <p class="continue">
        This works because <code>SubElement</code> returns the node it just created,
        so we can immediately set its <code>text</code> value.
      </p>

      <figure id="f:final_tree">
        <img src="img/web/final_tree.png" alt="Final Tree" />
      </figure>

      <p>
        In memory,
        our document is now something like <a href="#f:final_tree">Figure XXX</a>.
        If we convert it to text,
        we get:
      </p>

<pre>
<span class="out">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Dimorphism&lt;/h1&gt;&lt;p class="definition"&gt;Occurring or existing in two&crarr;
different &lt;u&gt;forms&lt;/u&gt;.&lt;/p&gt;&lt;p&gt;The most notable form is sexual dimorphism,
in which males and females have noticeably different appearances.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span>
</pre>

      <p class="continue">
        (As before, we use &crarr; to break a line that's too long to fit on the screen.)
        This has all the content we created,
        but <em>only</em> that content.
        We didn't create text nodes containing carriage returns and blanks,
        so <code>tostring</code> didn't insert them.
        Most machine-generated XML isn't nicely indented
        because computers don't care,
        but XML intended for human beings to read usually is.
      </p>

      <p>
        in practice,
        of course,
        programs usually wrap all these steps up in functions.
        For example,
        this function converts a Python list into an HTML ordered list:
      </p>

<pre src="src/web/list_to_ol.py">
import xml.etree.ElementTree as ET

def convert(values):
    '''Convert a list of values to an &lt;ol&gt; list.'''

    result = ET.Element('ol')
    for v in values:
        ET.SubElement(result, 'li').text = str(v)
    return result

root = convert([1, "two", 3.4])
print ET.tostring(root)
<span class="out">&lt;ol&gt;&lt;li&gt;1&lt;/li&gt;&lt;li&gt;two&lt;/li&gt;&lt;li&gt;3.4&lt;/li&gt;&lt;/ol&gt;</span>
</pre>

        <p>
          The line:
        </p>

<pre>
        ET.SubElement(result, 'li').text = str(v)
</pre>

        <p class="continue">
          does two things at once.
          First,
          it creates a new <code>li</code> (list element) node and returns it.
          Second,
          it sets the <code>text</code> of that node to be
          the string representation of the next list value.
          What it <em>doesn't</em> do is store a reference to that node in a separate variable.
          We could do this,
          as in:
        </p>

<pre>
    for v in values:
        node = ET.SubElement(result, 'li')
        node.text = str(v)
</pre>

        <p class="continue">
          It's a matter of taste which is less unreadable,
          but since we're about to see a different approach that most people find better anyway,
          the question is moot.
        </p>

      <div class="keypoints" id="k:creating">
        <h3>Summary</h3>
        <ul>
          <li>Use the same library to create elements in memory rather than concatenating and printing strings.</li>
          <li>An element's <code>text</code> property stores the text it contains.</li>
          <li>An element's <code>tail</code> property stores the text that comes immediately after it.</li>
        </ul>
      </div>

    </section>

    <section id="s:templating">

      <h2>A Better Way to Create Documents</h2>

      <div class="understand" id="u:templating">
        <h3>Understand:</h3>
        <ul>
          <li>How a page templating engine works.</li>
        </ul>
      </div>

      <p>
        Turning a Python list into an HTML <code>ol</code> or <code>ul</code> list
        seems like a natural thing to do,
        so you might expect that programmers would have created libraries to do it.
        In fact,
        they have gone one step further
        and creating systems that allow people to put bits of code directly into HTML files.
        Such a file is usually called a <a href="glossary.html#template">template</a>,
        since it is the general pattern for any number of potential pages.
      </p>

      <p>
        Here's a simple example.
        Suppose we want to create a set of web pages
        to display point-form biographies of famous scientists.
        We want each page to look like this:
      </p>

<pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Biography of Beatrice Tinsley&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Beatrice Tinsley&lt;/h1&gt;
    &lt;ol&gt;
      &lt;li&gt;Born 1941&lt;/li&gt;
      &lt;li&gt;Died 1981&lt;/li&gt;
      &lt;li&gt;Studied stellar aging&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        but since we expect to have hundreds of such pages,
        we don't want to write each one by hand.
        (We certainly don't want to have to <em>revise</em> each one by hand
        when the university decides it wants them in a slightly different format...)
        To make things easier on ourselves,
        let's create a single template page called <code>biography.html</code>
        that contains:
      </p>

<pre src="src/web/biography.html">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Biography of {{name}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
    &lt;ol&gt;
      {% for f in facts %}
      &lt;li&gt;{{f}}&lt;/li&gt;
      {% endfor %}
    &lt;/ol&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        This has the same general structure as a general biography,
        but there are a few changes:
        it uses <code>{{name}}</code> instead of the scientist's name,
        and rather than listing each biographical detail,
        it has something that looks a lot like a <code>for</code> loop
        that iterates over something called <code>facts</code>.
      </p>

      <p>
        What we need next is a program that can expand this template
        using particular values for <code>name</code> and <code>facts</code>.
        We will use a Python template library called Jinja2 to do this;
        there are many others
        but they all work in more or less the same way
        (which means, "They each have their own slightly different rules
        for what can go in a page and how it's expanded.").
      </p>

      <p>
        First,
        let's put all the values we want to customize the page with into variables:
      </p>

<pre src="src/web/template_expansion.py">
name = 'Beatrice Tinsley'
facts = ['Born 1941', 'Died 1981', 'Studied stellar aging']
</pre>

      <p>
        Next,
        we have to import the Jinja2 library
        and do a bit of magic to load the template for our page:
      </p>

<pre src="src/web/template_expansion.py">
import jinja2

loader = jinja2.FileSystemLoader(['.'])
environment = jinja2.Environment(loader=loader)
template = environment.get_template('biography.html')
</pre>

      <p class="continue">
        We start by importing the <code>jinja2</code> library,
        and then create an object called a "loader".
        Its job is to find template files for us;
        its argument is a list of the directories we want it to search (in order).
        For now,
        we are only looking in the current directory,
        so the list is just <code>['.']</code>.
      </p>

      <p>
        Once we have that loader,
        we use it to create a Jinja2 "environment",
        which&mdash;well, honestly,
        we don't need two separate layers for what we're doing,
        but more complicated applications might need several loaders,
        or might be expanding different sets of templates in different ways,
        and the complexity of the general case shows up here.
        What we <em>really</em> want is the next line,
        which asks the environment to load the template file <code>'biography.html'</code>
        and give us an object that knows how to expand itself.
      </p>

      <p>
        We're now ready to do the actual expansion:
      </p>

<pre src="src/web/template_expansion.py">
result = template.render(name=name, facts=facts)
print result
</pre>

      <p class="continue">
        When we call <code>template.render</code>,
        we pass it any number of name-value pairs.
        (Remember, the odd-looking expression <code>name=name</code> in the function call means,
        "Assign the value of the variable <code>name</code> to the parameter called <code>name</code>.")
        Those names are then available inside the template as variables,
        so that <code>{{name}}</code> is replaced with the value of <code>name</code>
        and we can iterate over the list in <code>facts</code>.
        The method call <code>template.render</code> "runs" the template
        as if it were a program,
        and returns the string that's created.
        When we print it out,
        we get:
      </p>

<pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Biography of Beatrice Tinsley&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Beatrice Tinsley&lt;/h1&gt;
    &lt;ol&gt;
      
      &lt;li&gt;Born 1941&lt;/li&gt;
      
      &lt;li&gt;Died 1981&lt;/li&gt;
      
      &lt;li&gt;Studied stellar aging&lt;/li&gt;
      
    &lt;/ol&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        Why go to all of this trouble?
        Because if we want to create another page with exactly the same format,
        all we have to do is call:
      </p>

<pre>
result = template.render(name='Helen Sawyer Hogg',
                         facts=['Born 1905',
                                'Died 1993',
                                'Studied globular clusters',
                                'Wrote a popular astronomy column for 30 years'])
</pre>

      <p class="continue">
        and we will get:
      </p>

<pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Biography of Helen Sawyer Hogg&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Helen Sawyer Hogg&lt;/h1&gt;
    &lt;ol&gt;
      
      &lt;li&gt;Born 1905&lt;/li&gt;
      
      &lt;li&gt;Died 1993&lt;/li&gt;
      
      &lt;li&gt;Studied globular clusters&lt;/li&gt;
      
      &lt;li&gt;Wrote a popular astronomy column for 30 years&lt;/li&gt;
      
    &lt;/ol&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        Jinja2 templates support all the basic features of Python.
        For example,
        we can modify our template file to say:
      </p>

<pre src="src/web/biography2.html">
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Biography of {{name}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
    <span class="highlight">{% if facts %}</span>
      &lt;ol&gt;
        {% for f in facts %}
        &lt;li&gt;{{f}}&lt;/li&gt;
        {% endfor %}
      &lt;/ol&gt;
    <span class="highlight">{% else %}
      &lt;p&gt;No facts available.&lt;p&gt;
    {% endif %}</span>
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p class="continue">
        so that if the list <code>facts</code> is empty,
        the page displays a paragraph saying that,
        rather than an empty ordered list.
      </p>

      <div class="box">

        <h3>Pros and Cons of Templating</h3>

        <p>
          Putting code in HTML templates and then expanding that to create actual pages
          has both advantages and drawbacks.
          The advantage is that simple things are simple to do:
          the biography template shown above is a lot easier to understand than either
          a bunch of <code>print</code> statements,
          or a set of functions that construct a tree of nodes in memory
          using <code>Element</code> and <code>SubElement</code> calls
          and then turn the result into a string.
        </p>

        <p>
          The biggest drawback of templating is the lack of support for debugging.
          It's very common for template expansion to do what you said,
          rather than what you meant,
          and working backward from a page that has the wrong content
          to the bits of template that weren't quite right
          can be complicated.
          One way to keep it manageable is
          to keep the templates as simple as possible.
          Any calculations more complicated than simple addition
          should be done in the program,
          and the result passed in as a variable.
          Similarly,
          while deeply-nested conditional statements in programs are hard to understand,
          their equivalents in templates are even harder,
          and so should be avoided.
        </p>

      </div>

      <div class="keypoints" id="k:templating">
        <h3>Summary</h3>
        <ul>
          <li>How to use a page templating system.</li>
        </ul>
      </div>

    </section>

    <section id="s:http">

      <h2>How the Web Works</h2>

      <div class="understand" id="u:http">
        <h3>Understand:</h3>
        <ul>
          <li>The difference between client-server and peer-to-peer architectures.</li>
          <li>What IP addresses, host names, and sockets are.</li>
          <li>HTTP's request-response cycle.</li>
          <li>What HTTP requests and responses contain.</li>
        </ul>
      </div>

      <p>
        Now that we know how to read and write the web's most common data format,
        it's time to look at how data is moved around on the web.
        Broadly speaking,
        web applications are built in one of two ways.
        In a <a href="glossary.html#client-server-architecture">client/server architecture</a>
        many <a href="glossary.html#client">clients</a>
        communicate with a central <a href="glossary.html#server">server</a>
        (<a href="#f:client_server">Figure XXX</a>).
        This model is asymmetric:
        clients ask for things,
        and servers provide them.
        Web browsers and web servers like Firefox and Apache are the best-known example of this model,
        but many <a href="db.html#a:dbms">database management systems</a>
        also use a client/server architecture.
      </p>

      <figure id="f:client_server">
        <img src="img/web/client_server.png" alt="Client-Server Architecture" />
      </figure>

      <p>
        In contrast,
        a <a href="glossary.html#peer-to-peer-architecture">peer-to-peer architecture</a>
        is one in which all processes exchange information equally
        (<a href="#f:peer_to_peer">Figure XXX</a>).
        This is symmetric:
        every participant both provides and receives data.
        The best-known example is probably filesharing systems like BitTorrent,
        but again,
        there are many others.
        Peer-to-peer systems are generally harder to design than client-server systems,
        but they are also more resilient:
        if a centralized web server fails,
        the whole system goes down,
        while if one node in a filesharing network goes down,
        the rest can (usually) carry on.
      </p>

      <figure id="f:peer_to_peer">
        <img src="img/web/peer_to_peer.png" alt="Peer-to-Peer Architecture" />
      </figure>

      <p>
        Under the hood,
        both kinds of systems
        (and pretty much every other networked application)
        run on a layered family of standards called
        <a href="glossary.html#internet-protocol">Internet Protocol</a> (IP).
        IP works by breaking messages down into small <a href="glossary.html#packet">packets</a>,
        each of which is forwarded from one machine to another
        along any available route
        until it reaches its destination
        (<a href="#f:packets">Figure XXX</a>).
      </p>

      <figure id="f:packets">
        <img src="img/web/packets.png" alt="Packet-Based Communication" />
      </figure>

      <p>
        The only layer in IP that concerns us is
        the <a href="glossary.html#tcp">Transmission Control Protocol</a> layer.
        TCP/IP guarantees that every packet we send is received,
        and that packets are received in the right order.
        Putting it another way,
        it provides a reliable stream of data from one place to another,
        so that sending data between computers looks as much as possible
        like reading and writing files.
        (<a href="#f:streams">Figure XXX</a>).
      </p>

      <figure id="f:streams">
        <img src="img/web/streams.png" alt="Building Streams Out of Packets" />
      </figure>

      <p>
        Programs using IP communicate through <a href="glossary.html#socket">sockets</a>.
        Each socket is one end of a point-to-point communication channel,
        and provides the same kind of read and write operations as files
        (<a href="#f:socket">Figure XXX</a>).
      </p>

      <figure id="f:socket">
        <img src="img/web/socket.png" alt="Sockets" />
      </figure>

      <p>
        A socket is identified by two numbers.
        The first is its <a href="glossary.html#host-address">host address</a>
        or <a href="glossary.html#ip-address">IP address</a>,
        which identifies a particular machine on the network.
        This consists of four 8-bit numbers,
        such as <code>208.113.154.118</code>.
        The <a href="glossary.html#dns">Domain Name System</a> (DNS)
        matches these numbers to symbolic names
        like <code>"software-carpentry.org"</code>.
        If we want,
        we can use tools like <code>nslookup</code> to query DNS directly:
      </p>

<pre>
$ <span class="in">nslookup software-carpentry.org</span>
<span class="out">Server:  admin1.private.tor1.mozilla.com
Address:  10.242.75.5

Non-authoritative answer:
Name:    software-carpentry.org
Address:  173.236.199.157</span>
</pre>

      <p>
        A socket's <a href="glossary.html#port">port number</a>
        is just a number in the range 0-65535
        that uniquely identifies the socket on the host machine.
        (If the IP address is like a university's phone number,
        then the port number is the extension.)
        Ports 0-1023 are reserved for the operating system's use;
        anyone else can use the remaining ports.
      </p>

      <figure id="f:sockets">
        <img src="img/web/sockets.png" alt="Sockets"/>
      </figure>

      <p>
        The <a href="glossary.html#http">Hypertext Transfer Protocol</a> (HTTP)
        is a layer on top of TCP/IP
        that specifies one way for programs to exchange information.
        Originally,
        the communicating parties were web browsers and web servers,
        but these days HTTP is used by many other kinds of applications as well.
        In principle,
        HTTP communication is simple:
        the client sends a request specifying what it wants over a socket connection,
        and the server sends some data in response.
        (or an error message).
        The data may be HTML copied from a file on disk,
        a similar page generated dynamically by a program,
        an image,
        or just about anything else
        (<a href="#f:http_content">Figure XXX</a>).
      </p>

      <div class="box">
        <h3>The Internet vs. the Web</h3>

        <p>
          A lot of people use these two terms synonymously,
          but they're actually very different things.
          The Internet is a network of networks
          that allows (almost) any computer to communicate with (almost) any other.
          That communication can be email,
          File Transfer Protocol (FTP),
          streaming video,
          or any of a hundred other things.
        </p>

        <p>
          The World-Wide Web,
          on the other hand,
          is just one particular way to share data on top of
          the kind of network that the Internet provides.
          Originally,
          the web only allows people to view documents in browsers,
          but its HTTP protocol has been used to do many other things since
          (such as instant messaging and gaming).
        </p>

      </div>

      <figure id="f:http_content">
        <img src="img/web/http_content.png" alt="HTTP Content" />
      </figure>

      <figure id="f:http_cycle">
        <img src="img/web/http_cycle.png" alt="HTTP Request Cycle"/>
      </figure>

      <figure id="f:http_request">
        <img src="img/web/http_request.png" alt="HTTP Request"/>
      </figure>

      <p>
        An HTTP request has three parts
        (<a href="#f:http_request">Figure XXX</a>).
        The HTTP method is almost always either
        <code>"GET"</code> (to fetch information)
        or
        <code>"POST"</code> (to submit form data or upload files).
        The URL identifies the thing the request wants;
        it may be a path to a file on disk,
        such as <code>/research/experiments.html</code>,
        but it's entirely up to the server to decide what to send back.
        The HTTP version is usually <code>"HTTP/1.0"</code> or <code>"HTTP/1.1"</code>;
        the differences between the two don't matter to us.
      </p>

      <p>
        An <a href="glossary.html#http-header">HTTP header</a> is a key/value pair,
        such as the three shown below:
      </p>

<pre>
Accept: text/html
Accept-Language: en, fr
If-Modified-Since: 16-May-2005
</pre>

      <p class="continue">
        A key may appear any number of times,
        so that (for example)
        a request can specify that it's willing to accept several types of content.
      </p>

      <p>
        The body is any extra data associated with the request.
        This is used when submitting data via web forms,
        when uploading files,
        and so on.
        There <em>must</em> be a blank line between the last header and the start of the body
        to signal the end of the headers;
        forgetting it is a common mistake.
      </p>

      <p>
        One header,
        called <code>Content-Length</code>,
        tells the server how many bytes to expect to read in the body of the request.
        There's no magic in any of this:
        an HTTP request is just text,
        and any program that wants to can create one or parse one.
      </p>

      <figure id="f:http_response">
        <img src="img/web/http_response.png" alt="HTTP Response"/>
      </figure>

      <p>
        HTTP responses are formatted like HTTP requests
        (<a href="#f:http_response">Figure XXX</a>).
        The version, headers, and body have the same form
        and mean the same thing.
        The status code is a number indicating what happened
        when the request was processed by the server.
        200 means "everything worked",
        404 means "not found",
        and other codes have other meanings
        (<a href="#f:http_codes">Figure XXX</a>).
        The status phrase repeats that information in a human-readable phrase
        like "OK" or "not found".
      </p>

      <figure id="f:http_codes">
        <table>
          <tr>
            <th>Code</th>
            <th>Name</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>100</td>
            <td>Continue</td>
            <td>Client should continue sending data</td>
          </tr>
          <tr>
            <td>200</td>
            <td>OK</td>
            <td>The request has succeeded</td>
          </tr>
          <tr>
            <td>204</td>
            <td>No Content</td>
            <td>The server has completed the request, but doesn't need to return any data</td>
          </tr>
          <tr>
            <td>301</td>
            <td>Moved Permanently</td>
            <td>The requested resource has moved to a new permanent location</td>
          </tr>
          <tr>
            <td>307</td>
            <td>Temporary Redirect</td>
            <td>The requested resource is temporarily at a different location</td>
          </tr>
          <tr>
            <td>400</td>
            <td>Bad Request</td>
            <td>The request is badly formatted</td>
          </tr>
          <tr>
            <td>401</td>
            <td>Unauthorized</td>
            <td>The request requires authentication</td>
          </tr>
          <tr>
            <td>404</td>
            <td>Not Found</td>
            <td>The requested resource could not be found</td>
          </tr>
          <tr>
            <td>408</td>
            <td>Timeout</td>
            <td>The server gave up waiting for the client</td>
          </tr>
          <tr>
            <td>418</td>
            <td>I'm a teapot</td>
            <td>No, really</td>
          </tr>
          <tr>
            <td>500</td>
            <td>Internal Server Error</td>
            <td>An error occurred in the server that prevented it fulfilling the request</td>
          </tr>
          <tr>
            <td>601</td>
            <td>Connection Timed Out</td>
            <td>The server did not respond before the connection timed out</td>
          </tr>
        </table>
        <figcaption>HTTP Codes</figcaption>
        <!-- FIXME: add "I am a teapot" -->
      </figure>

      <p>
        The one other thing that we need to know about HTTP is that
        it is <a href="glossary.html#stateless-protocol">stateless</a>:
        each request is handled on its own,
        and the server doesn't remember anything between one request and the next.
        If an application wants to keep track of something like a user's identity,
        it must do so itself.
      </p>

      <div class="keypoints" id="k:http">
        <h3>Summary</h3>
        <ul>
          <li>Most communication on the web uses TCP/IP sockets.</li>
          <li>Socket endpoints are identified by a host address and a port number.</li>
          <li>The Domain Name System translates human-readable names into host addresses.</li>
          <li>An HTTP request contains a method, headers, and a body.</li>
          <li>An HTTP response also contains a response code.</li>
          <li>HTTP is a stateless request-response protocol.</li>
        </ul>
      </div>

    </section>

    <section id="s:client">

      <h2>Getting Data</h2>

      <div class="understand" id="u:client">
        <h3>Understand:</h3>
        <ul>
          <li>How to get data from the web using HTTP.</li>
          <li>How URL query parameters are formatted.</li>
        </ul>
      </div>

      <p>
        Opening sockets, constructing HTTP requests, and parsing responses is tedious,
        so most people use libraries to do most of the work.
        Python comes with such a library called <code>urllib2</code>
        (because it's a replacement for an earlier library called <code>urllib</code>),
        but it exposes a lot of plumbing that most people never want to care about.
        Instead,
        we recommend using the <code>Requests</code> library.
        Here's an example that uses it to download a page from our web site:
      </p>

<pre src="src/web/requests_client.py">
import requests
response = requests.get("http://software-carpentry.org/testpage.html")
print 'status code:', response.status_code
print 'content length:', response.headers['content-length']
print response.text
<span class="out">status code: 200
content length: 126
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Software Carpentry Test Page&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Use this page to test requests.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</span>
</pre>

      <p>
        Sometimes a URL isn't enough on its own:
        for example,
        when searching on Google,
        we have to specify what the search terms are.
        We could add these to the path in the URL,
        but then every web site could have a different convention about
        which parts actually belong to the path
        and which are extras.
        Instead,
        what we should do is add parameters to the URL
        by putting a '?' on the end of the URL,
        then adding key-value pairs separated by the '&amp;' character.
        For example,
        the URL <code>http://www.google.ca?q=Python</code>
        ask Google to search for pages related to Python,
        while
        <code>http://www.google.ca/search?q=Python&amp;client=Firefox</code>
        also tells Google that we're using Firefox.
        We can pass whatever parameters we want,
        whenever we want,
        but it's up to the application running on the web site to decide
        which ones to pay attention to,
        and how to interpret them.
      </p>

      <div class="box">
        <h3>You Are Who You Say You Are</h3>

        <p>
          Yes,
          this means that we could write a program of our own
          that tells websites it's Firefox,
          Internet Explorer,
          or pretty much anything else.
          We'll return to this and other security issues later.
        </p>
      </div>

      <p>
        Of course,
        if '?' and '&amp;' are special characters,
        there must be a way to escape them.
        The <a href="glossary.html#url-encoding">URL encoding</a> standard
        represents special characters using <code>"%"</code> followed by a 2-digit hexadecimal code,
        and replaces spaces with the '+' character
        (<a href="#f:url_encoding">Figure XXX</a>).
        Thus,
        to search Google for "grade&nbsp;=&nbsp;A+" (with the spaces),
        we would use the URL <code>http://www.google.ca/search?q=grade+%3D+A%2B</code>.
      </p>

      <figure id="f:url_encoding">
        <table>
          <tr>
            <th>Character</th>
            <th>Encoding</th>
          </tr>
          <tr>
            <td><code>"#"</code></td>
            <td><code>%23</code></td>
          </tr>
          <tr>
            <td><code>"$"</code></td>
            <td><code>%24</code></td>
          </tr>
          <tr>
            <td><code>"%"</code></td>
            <td><code>%25</code></td>
          </tr>
          <tr>
            <td><code>"&amp;"</code></td>
            <td><code>%26</code></td>
          </tr>
          <tr>
            <td><code>"+"</code></td>
            <td><code>%2B</code></td>
          </tr>
          <tr>
            <td><code>","</code></td>
            <td><code>%2C</code></td>
          </tr>
          <tr>
            <td><code>"/"</code></td>
            <td><code>%2F</code></td>
          </tr>
          <tr>
            <td><code>":"</code></td>
            <td><code>%3A</code></td>
          </tr>
          <tr>
            <td><code>";"</code></td>
            <td><code>%3B</code></td>
          </tr>
          <tr>
            <td><code>"="</code></td>
            <td><code>%3D</code></td>
          </tr>
          <tr>
            <td><code>"?"</code></td>
            <td><code>%3F</code></td>
          </tr>
          <tr>
            <td><code>"@"</code></td>
            <td><code>%40</code></td>
          </tr>
        </table>
        <figcaption>URL Encoding</figcaption>
      </figure>

      <p>
        Encoding things by hand is very error-prone,
        so the Requests library lets us pass in
        a dictionary of key-value pairs instead
        via the keyword argument <code>params</code>:
      </p>

<pre src="src/web/urlencode.py">
import requests
parameters = {'q' : 'Python', 'client' : 'Firefox'}
response = requests.get('http://www.google.com/search', params=parameters)
print 'actual URL:', response.url
<span class="out">actual URL: http://www.google.com/search?q=Python&amp;client=Firefox</span>
</pre>

      <p class="continue">
        You should <em>always</em> let the library build the URL for you,
        rather than doing it yourself:
        there are lots of subtleties we haven't covered,
        and even if there weren't,
        there's no point duplicating code that's already been written and tested.
      </p>

      <p>
        Suppose we want to write a script that actually <em>does</em> search Google.
        Constructing a URL is easy.
        Sending it and reading the response is easy too,
        but parsing the response is hard,
        since there's a lot of stuff in the page that Google sends back.
        Many first-generation web applications relied on
        <a href="glossary.html#screen-scraping">screen scraping</a>
        to get data,
        i.e.,
        they would search for substrings in the HTML.
        (They had to do this because a lot of hand-written HTML was improperly formatted.
        For example,
        it was quite common to use <code>&lt;br&gt;</code> on its own to break a line.)
      </p>

      <p>
        Screen scraping is always hard to get right if the page layout is complex.
        It is also fragile:
        whenever the layout of the pages changes,
        the application will most likely break
        because data is no longer where it was.
      </p>

      <p>
        Most modern web applications try to sidestep this problem
        by providing some sort of <a href="glossary.html#web-services">web services</a> interface.
        When a client sends a request,
        it indicates whether it wants machine-oriented data or human-readable HTML
        (<a href="#f:web_services">Figure XXX</a>).
        If it asks for the former,
        the server sends back XML (or some other format)
        that is easy for a program to parse.
        If the client asks for "real" HTML,
        on the other hand,
        the application turns that data into HTML tables with italics and colored highlights and the like
        to make it easy for human beings to read.
      </p>

      <figure id="f:web_services">
        <img src="img/web/web_services.png" alt="Web Services"/>
      </figure>

      <p>
        Using "live" data from a web service is a powerful way to get a lot of science done in a hurry,
        but only when it works.
        As a case in point,
        we wanted to use bird-watching data from <a href="http://ebird.org">ebird.org</a> in this example,
        but their server was locked down for security reasons
        when it came time for us to write our examples.
        (This is another way in which software is like other experimental apparatus:
        odds are that when you need it most,
        it will be broken or someone will have borrowed it.)
      </p>

      <p>
        We therefore chose to use climate data from the World Bank instead.
        According to <a href="http://data.worldbank.org/developers/climate-data-api">the documentation</a>,
        data for a particular country can be found at:
      </p>

<pre>
http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/<em>VARIABLE</em>/year/<em>ISO</em>.<em>FORMAT</em>
</pre>

      <p class="continue">
        where:
      </p>

      <ul>
        <li>
          <em>VARIABLE</em> is either "pr" (for precipitation)
          or "tas" (for <em>t</em>emperature <em>a</em>t <em>s</em>urface);
        </li>
        <li>
          <em>ISO</em> is the International Standards Organization's 3-letter country code
          for the country of interest
          (e.g., "FRA" for France);
          and
        </li>
        <li>
          <em>FORMAT</em> is "XML" for XML,
          and other strings for other formats
          that we'll discuss later.
        </li>
      </ul>

      <p>
        Let's try getting some data:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import requests</span>
&gt;&gt;&gt; <span class="in">url = 'http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/FRA.XML'</span>
&gt;&gt;&gt; <span class="in">response = requests.get(url)</span>
&gt;&gt;&gt; <span class="in">print response.text</span>
<span class="out">&lt;list&gt;
  &lt;domain.web.V1WebCru&gt;
    &lt;year&gt;1901&lt;/year&gt;
    &lt;data&gt;21.357021&lt;/data&gt;
  &lt;/domain.web.V1WebCru&gt;
  &lt;domain.web.V1WebCru&gt;
    &lt;year&gt;1902&lt;/year&gt;
    &lt;data&gt;21.382462&lt;/data&gt;
  &lt;/domain.web.V1WebCru&gt;
  ...
&lt;/list&gt;</span>
</pre>

      <p>
        All right:
        the outer <code>list</code> element (the document root)
        contains any number of <code>domain.web.V1WebCru</code> elements,
        each of which contains <code>year</code> and <code>data</code> elements.
        That long, clumsy name <code>domain.web.V1WebCru</code> probably means something to someone,
        but we don't need to care:
        all we need to know is that each element with that tag
        contains a single year's data.
      </p>

      <p>
        Let's write a program to compare the data for two countries
        (which is the problem Carla wanted to solve at the start of this chapter).
        We need to know which countries to compare:
      </p>

<pre src="src/web/temperatures.py">
def main(args):
    first_country = 'AUS'
    second_country = 'CAN'
    if len(args) &gt; 0:
        first_country = args[0]
    if len(args) &gt; 1:
        second_country = args[1]
    ratios(first_country, second_country)

if __name__ == '__main__':
    main(sys.argv[1:])
</pre>

      <p>
        This program uses a function called <code>ratios</code>
        to fetch data and display the annual ratios:
      </p>

<pre src="src/web/temperatures.py">
def ratios(first_country, second_country):
    '''Show ratio of average temperatures for two countries over time.'''
    first = get_temps(first_country)
    second = get_temps(second_country)
    assert len(first) == len(second), 'Length mis-match in results'
    keys = first.keys()
    keys.sort()
    for k in keys:
        print k, first[k] / second[k]
</pre>

      <p>
        <code>ratios</code> depends in turn on a function <code>get_temps</code>:
      </p>

<pre src="src/web/temperatures.py">
def get_temps(country_code):
    '''Get annual temperatures for a country.'''
    doc = get_xml(country_code)
    result = {}
    for element in doc.findall('domain.web.V1WebCru'):
        year = find_one(element, 'year').text
        temp = find_one(element, 'data').text
        result[int(year)] = kelvin(float(temp))
    return result
</pre>

      <p class="continue">
        which depends on a helper function called <code>get_xml</code>
        to actually download text from the World Bank web site
        and parse it to produce an XML document:
      </p>

<pre src="src/web/temperatures.py">
def get_xml(country_code):
    '''Get XML temperature data for a country.'''
    url = 'http://climatedataapi.worldbank.org/climateweb/rest/v1/country/cru/tas/year/%s.XML'
    u = url % country_code
    response = requests.get(u)
    doc = ET.fromstring(response.text)
    return doc
</pre>

      <p class="continue">
        The last two functions we need to finish this program are <code>kelvin</code>,
        which converts temperatures from Celsius to Kelvin,
        and <code>find_one</code>,
        which pulls exactly one node out of an XML document:
      </p>

<pre src="src/web/temperatures.py">
def kelvin(celsius):
    '''Convert degrees C to degrees K.'''
    return celsius + 273.15

def find_one(node, pattern):
    '''Get exactly one child that matches an XPath pattern.'''
    all_results = node.findall(pattern)
    assert len(all_results) == 1, 'Got %d children instead of 1' % len(all_results)
    return all_results[0]
</pre>

      <p>
        Let's try running this program with no arguments
        to compare Australia to Canada, eh:
      </p>

<pre>
$ <span class="in">python temperatures.py</span>
<span class="out">1901 1.10934799048
1902 1.11023963325
1903 1.10876094164
...  ...
2007 1.10725265753
2008 1.10793365185
2009 1.10865537105</span>
</pre>

      <p class="continue">
        and then with arguments to compare Malaysia to Norway:
      </p>

<pre>
$ <span class="in">python temperatures.py MYS NOR</span>
<span class="out">1901 1.08900632708
1902 1.09536126502
1903 1.08935268463
...  ...
2007 1.08564675748
2008 1.08481881663
2009 1.08720464013</span>
</pre>

      <p>
        Only 24 lines in this program do anything webbish
        (the functions <code>get_temps</code>, <code>get_xml</code>, and <code>find_one</code>),
        and six of those lines are blank or documentation.
        The remaining 30 lines are the user interface
        (handling command-line arguments and printing output)
        and data manipulation
        (converting temperatures and calculating ratios).
      </p>

      <div class="keypoints" id="k:client">
        <h3>Summary</h3>
        <ul>
          <li>Use Python's Requests library to make HTTP requests.</li>
          <li>Let the library format URL parameters.</li>
          <li>Many web sites now provide machine-oriented data as well as human-readable pages.</li>
          <li>The URLs and query parameters needed to fetch data are specified by the web site.</li>
        </ul>
      </div>

    </section>

    <section id="s:server">

      <h2>Providing Data</h2>

      <div class="understand" id="u:server">
        <h3>Understand:</h3>
        <ul>
          <li>That writing secure dynamic web applications is hard.</li>
          <li>That providing dynamically-generated static pages is a good alternative.</li>
          <li>How and why to create an index for such pages.</li>
          <li>How to keep track of what dynamic data has already been processed.</li>
        </ul>
      </div>

      <p>
        The next logical step is to provide data to others
        by writing some kind of server application.
        The basic idea is simple:
        wait for someone to connect to your server and send you an HTTP request,
        parse that request,
        figure out what it's asking for,
        fetch that data (or run a program to generate some data dynamically),
        format the data as HTML or XML,
        and send it back
        (<a href="#f:web_application">Figure XXX</a>).
      </p>

      <figure id="f:web_application">
        <img src="img/web/web_application.png" alt="Web Application Lifecycle"/>
      </figure>

      <p>
        We're not going to show you how to do this,
        though,
        because experience has shown that all we can actually do in a short lecture
        is show you how to create security holes.
        Here's just one example.
        Suppose you want to write a web application that accepts URLs of the form
        <code>http://my.site/data?species=homo.sapiens</code>
        and fetches a database record
        containing information about that species.
        One way to do it in Python might look like this:
      </p>

<pre>
def get_species(url):
    '''Get data for a particular species.'''
    params = url.split('?')[1]                                # Get everything after the '?'
    pairs = params.split('&amp;')                                 # Get the name1=value1&amp;name2=value2 pairs
    pairs = [pairs.split('=') for p in pairs]                 # Split the name=value pairs
    pairs = dict(pairs)                                       # Convert to a {name : value} dictionary
    species = pairs['species']                                # Get the species we want to look up
    sql = '''SELECT * FROM Species WHERE Name = "%s";'''      # Template for SQL query
    sql = sql % species                                       # Insert the species name
    cursor.execute(sql)                                       # Send query to database
    results = cursor.fetchall()                               # Get all the results
    return results[0]
</pre>

      <p>
        We've taken out all the error-checking&mdash;for example,
        this code will fail if there aren't actually any query parameters,
        or if the species' name isn't in the database&mdash;but
        that's not the problem.
        The problem is what happens if someone sends us this URL:
      </p>

<pre>
http://my.site/data?species=homo.sapiens&quot;;DROP TABLE Species&quot;--
</pre>

      <p class="continue">
        Why?
        Because the dictionary of query parameters produced by
        the first five lines of the function
        will be:
      </p>

<pre>
{ 'species' : 'homo.sapiens&quot;;DROP TABLE Species;--' }
</pre>

      <p class="continue">
        which means that the SQL query will be:
      </p>

<pre>
SELECT * FROM Species WHERE Name = "homo.sapiens&quot;;DROP TABLE Species;--";
</pre>

      <p class="continue">
        which is the same as:
      </p>

<pre>
SELECT * FROM Species WHERE Name = "homo.sapiens";
DROP TABLE Species;
</pre>

      <p>
        In other words,
        this selects something from the database,
        then throws away the entire <code>Species</code> table.
        It's called an <a href="glossary.html#sql-injection">SQL injection attack</a>,
        because the user is injecting arbitrary (and usually damaging) SQL
        into our database query,
        and it's just one of hundreds of different ways that villains can try to compromise a web application.
      </p>

      <p>
        Built properly,
        web sites can withstand such attacks,
        but learning how to do things properly takes a long time.
        Instead,
        we will look at how to write programs that create plain old HTML pages
        that can then be served up to the world by a standard web server.
        Using our previous example (ratios of average annual temperatures) as a starting point,
        we'll create pages whose names look like
        <code>http://my.site/tempratio/AUS-CAN.html</code>,
        and which contain data formatted like this:
      </p>

<pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;meta name="revised" content="2012-09-15" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Ratio of Average Annual Temperatures for AUS and CAN&lt;/h1&gt;
    &lt;table class="data"&gt;
      &lt;tr&gt;
        &lt;td class="year"&gt;1901&lt;/td&gt;
        &lt;td class="data"&gt;1.10934799048&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td class="year"&gt;1902&lt;/td&gt;
        &lt;td class="data"&gt;1.11023963325&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td class="year"&gt;1903&lt;/td&gt;
        &lt;td class="data"&gt;1.10876094164&lt;/td&gt;
      &lt;/tr&gt;
      ...
      &lt;tr&gt;
        &lt;td class="year"&gt;2007&lt;/td&gt;
        &lt;td class="data"&gt;1.10725265753&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td class="year"&gt;2008&lt;/td&gt;
        &lt;td class="data"&gt;1.10793365185&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
        &lt;td class="year"&gt;2009&lt;/td&gt;
        &lt;td class="data"&gt;1.10865537105&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        The first step is to calculate ratios,
        which we did in the <a href="#s:client">previous section</a>.
        Our main program is:
      </p>

<pre src="src/web/make_data_page.py">
def main(args):
    '''Create web page showing temperature ratios for two countries.'''

    assert len(args) == 4, \
           'Usage: make_data_page template_filename output_filename country_1 country_2'
    template_filename = args[0]
    output_filename = args[1]
    country_1 = args[2]
    country_2 = args[3]

    page = make_page(template_filename, country_1, country_2)

    writer = open(output_filename, 'w')
    writer.write(page)
    writer.close()
</pre>

      <p>
        The second step is to translate the temperature values into a web page.
        We'll use the <code>get_temps</code> function we wrote above
        to grab temperature data,
        get the years from that,
        and add the date as well.
        Once we have all those
      </p>

<pre src="src/web/make_data_page.py">
def make_page(template_filename, output_filename, country_1, country_2):
    '''Create page showing temperature ratios.'''

    data_1 = get_temps(country_1)
    data_2 = get_temps(country_2)
    years = data_1.keys()
    years.sort()
    the_date = date.isoformat(date.today())

    loader = jinja2.FileSystemLoader(['.'])
    environment = jinja2.Environment(loader=loader)
    template = environment.get_template(template_filename)
    result = template.render(country_1=country_1, data_1=data_1,
                             country_2=country_2, data_2=data_2,
                             years=years, the_date=the_date)

    return result
</pre>

      <p>
        Finally,
        we need a Jinja2 template for the pages we want to create:
      </p>

<pre src="src/web/temp_ratio.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Temperature Ratios of {{country_1}} and {{country_2}} as of {{the_date}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Temperature Ratios of {{country_1}} and {{country_2}}&lt;/h1&gt;
    &lt;h2&gt;Calculated {{the_date}}&lt;/h2&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td&gt;Year&lt;/td&gt;
        &lt;td&gt;{{country_1}}&lt;/td&gt;
        &lt;td&gt;{{country_2}}&lt;/td&gt;
        &lt;td&gt;Ratio&lt;/td&gt;
      &lt;/tr&gt;
      {% for year in years %}
      &lt;tr&gt;
        &lt;td&gt;{{year}}&lt;/td&gt;
        &lt;td&gt;{{data_1[year]}}&lt;/td&gt;
        &lt;td&gt;{{data_2[year]}}&lt;/td&gt;
        &lt;td&gt;{{data_1[year] / data_2[year]}}&lt;/td&gt;
      &lt;/tr&gt;
      {% endfor %}
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        Let's run it for Australia and Canada:
      </p>

<pre>
$ <span class="in">python make_data_page.py temp_ratio.html /tmp/aus-can.html AUS CAN</span>
</pre>

      <p class="continue">
        Sure enough,
        the file <code>/tmp/aus-can.html</code>contains:
      </p>

<pre src="src/web/aus-can-ratio.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Temperature Ratios of AUS and CAN as of 2013-02-10&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Temperature Ratios of AUS and CAN&lt;/h1&gt;
    &lt;h2&gt;Calculated 2013-02-10&lt;/h2&gt;
    &lt;table&gt;
      &lt;tr&gt;
        &lt;td&gt;Year&lt;/td&gt;
        &lt;td&gt;AUS&lt;/td&gt;
        &lt;td&gt;CAN&lt;/td&gt;
        &lt;td&gt;Ratio&lt;/td&gt;
      &lt;/tr&gt;
      
      &lt;tr&gt;
        &lt;td&gt;1901&lt;/td&gt;
        &lt;td&gt;294.507021&lt;/td&gt;
        &lt;td&gt;265.477581&lt;/td&gt;
        &lt;td&gt;1.10934799048&lt;/td&gt;
      &lt;/tr&gt;
      
      &lt;tr&gt;
        &lt;td&gt;1902&lt;/td&gt;
        &lt;td&gt;294.532462&lt;/td&gt;
        &lt;td&gt;265.2872886&lt;/td&gt;
        &lt;td&gt;1.11023963325&lt;/td&gt;
      &lt;/tr&gt;

      ...
      
      &lt;tr&gt;
        &lt;td&gt;2009&lt;/td&gt;
        &lt;td&gt;295.07194&lt;/td&gt;
        &lt;td&gt;266.1529883&lt;/td&gt;
        &lt;td&gt;1.10865537105&lt;/td&gt;
      &lt;/tr&gt;
      
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

    </section>

    <section id="s:index">

      <h2>Creating an Index</h2>

      <div class="understand" id="u:index">
        <h3>Understand:</h3>
        <ul>
          <li>That good data sets have an index.</li>
        </ul>
      </div>

      <p>
        Before leaving Carla's climate problem,
        let's go one step further and make our solution more useful.
        If we're going to calculate these tables for many different countries,
        how will other scientists know which ones we've done?
        In other words,
        how can we make our data findable?
      </p>

      <p>
        The standard answer for the last few hundred years has been,
        "Create an index."
        On the web,
        we can do this by creating a file called <code>index.html</code>
        and putting it in the directory that holds our data files,
        because by default,
        most web servers will give clients that file
        when they're asked for the directory itself.
        In other words,
        if someone points a browser (or any other program)
        at <code>http://my.site/tempratio/</code>,
        the web server will look for <code>/tempratio</code>.
        When it realizes that path is a directory rather than a file,
        it will look inside that directory for a file called <code>index.html</code>
        and return that.
        This is <em>not</em> guaranteed&mdash;system administrators
        can and do set up other default behaviors&mdash;but it is a common convention,
        and we can always tell our colleagues to fetch
        <code>http://my.site/tempratio/</code>
        if they want the current index anyway.
      </p>

      <p>
        What should be in <code>index.html</code>?
        The answer is simple:
        a table of some kind showing what files are available
        and when they were created.
        The first piece of information is the most important;
        the second allows users to determine
        what has been added since they last looked at our site
        without having to download actual data files.
        Our <code>index.html</code> will therefore be something like this:
      </p>

<pre>
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Index of Average Annual Temperature Ratios&lt;/title&gt;
    &lt;meta name="revised" content="2012-09-15" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Index of Average Annual Temperature Ratios&lt;/h1&gt;
    &lt;table class="data"&gt;
      &lt;tr&gt;
        &lt;td class="country"&gt;AUS&lt;/td&gt;
        &lt;td class="country"&gt;CAN&lt;/td&gt;
        &lt;td class="revised"&gt;2012-09-12&lt;/td&gt;
      &lt;/tr&gt;
      ...
      &lt;tr&gt;
        &lt;td class="country"&gt;MYS&lt;/td&gt;
        &lt;td class="country"&gt;NOR&lt;/td&gt;
        &lt;td class="revised"&gt;2012-09-15&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        Unlike our actual data files,
        this file is added to incrementally:
        each time we generate a new version,
        we have to include all the data that was in the old version as well.
        We therefore need to remember what we've done.
        The usual way to do this in a real application is to use a database,
        but for our purposes,
        a plain old text file will suffice.
      </p>

      <p>
        Now,
        we <em>could</em> make up a format to store the information we need,
        such as:
      </p>

<pre>
Updated 2013-05-09
AUS CAN 2013-03-07
AUS NOR 2013-03-09
CAN NOR 2013-04-22
CAN MDG 2013-05-09
</pre>

      <p class="continue">
        but there's a better solution.
        A growing number of applications use a data format called
        <a href="glossary.html#json">JSON</a>,
        which stands for "JavaScript Object Notation".
        Despite the name,
        it is a language-independent way to store nested data structures
        made up of lists, dictionaries, strings, numbers, Booleans,
        and the special value <code>null</code> (equivalent to Python's <code>None</code>).
        Here's a program that creates a dictionary representing the four data sets listed above
        and saves it in <code>index.json</code>:
      </p>

<pre src="src/web/create-index.py">
import json

index_data = {
    'updated' : '2013-05-09',
    'entries' : [
        ['AUS', 'CAN', '2013-03-07'],
        ['AUS', 'NOR', '2013-03-09'],
        ['CAN', 'NOR', '2013-04-22'],
        ['CAN', 'MDG', '2013-05-09']
    ]
}

writer = open('index.json', 'w')
json.dump(index_data, writer)
writer.close()
</pre>

      <p>
        When we run this,
        it creates a file called <code>index.json</code> that contains:
      </p>

<pre src="src/web/index.json">
{"updated": "2013-05-09", "entries": [["AUS", "CAN", "2013-03-07"], ["AUS", "NOR", "2013-03-09"], ["CAN", "NOR", "2013-04-22"], ["CAN", "MDG", "2013-05-09"]]}
</pre>

      <p class="continue">
        If we want to check that it has worked,
        we can read the file's contents back in to re-create the original data structure:
      </p>

<pre>
&gt;&gt;&gt; <span class="in">import json</span>
&gt;&gt;&gt; <span class="in">reader = open('index.json', 'r')</span>
&gt;&gt;&gt; <span class="in">check = json.load(reader)</span>
&gt;&gt;&gt; <span class="in">print check</span>
<span class="out">{u'updated': u'2013-05-09', u'entries': [[u'AUS', u'CAN', u'2013-03-07'], [u'AUS', u'NOR', u'2013-03-09'], [u'CAN', u'NOR', u'2013-04-22'], [u'CAN', u'MDG', u'2013-05-09']]}</span>
</pre>

      <p class="continue">
        The only catch here is that the strings loaded back in are Unicode,
        but we can safely ignore that for now.
        Instead,
        let's rewrite the main function of our program
        so that it creates the index as well as the individual page:
      </p>

<pre src="src/web/make_indexed_page.py">
import sys
import os
from datetime import date
import jinja2
import json
from temperatures import get_temps

INDIVIDUAL_PAGE = 'temp_ratio.html'
INDEX_PAGE = 'index.html'
INDEX_FILE = 'index.json'

def main(args):
    '''
    Create web page showing temperature ratios for two countries,
    and update the index.html page with the new entry.
    '''

    assert len(args) == 4, \
           'Usage: make_indexed_page template_dir output_dir country_1 country_2'
    template_dir = args[0]
    output_dir = args[1]
    country_1 = args[2]
    country_2 = args[3]
    the_date = date.isoformat(date.today())

    loader = jinja2.FileSystemLoader([template_dir])
    environment = jinja2.Environment(loader=loader)

    page = make_page(environment, country_1, country_2, the_date)
    save_page(output_dir, '%s-%s.html' % (country_1, country_2), page)

    index_data = load_index(output_dir, INDEX_FILE)
    index_data['entries'].append([country_1, country_2, the_date])
    save_page(output_dir, INDEX_FILE, json.dumps(index_data))

    page = make_index(environment, index_data)
    save_page(output_dir, INDEX_PAGE, page)
</pre>

      <p class="continue">
        Since we will be expanding templates in a couple of different functions,
        we move the creation of the Jinja2 environment to the main program.
        We then pass that variable into <code>make_page</code>
        and a new function called <code>update_index</code>,
        and use another new function <code>save_page</code>
        to save generated pages where they need to go.
        (Note that we update the index data <em>before</em> rewriting the index HTML page.
        The first version of this program that we wrote updated the HTML page
        before updating the data it was based on&mdash;oops.)
      </p>

      <p>
        <code>save_page</code> is the simplest of these pages to write,
        so let's do that:
      </p>

<pre src="src/web/make_indexed_page.py">
def save_page(output_dir, page_name, content):
    '''Save text in a file output_dir/page_name.'''
    path = os.path.join(output_dir, page_name)
    writer = open(path, 'w')
    writer.write(content)
    writer.close()
</pre>

      <p>
        Our revised <code>make_page</code> function is shorter than our original,
        since the environment is now being created in <code>main</code>.
        <code>make_page</code> is also now being passed the date
        (since that is used to update the index as well),
        and uses a fixed template specified by the global variable
        <code>INDIVIDUAL_PAGE</code>.
        The result is:
      </p>

<pre src="src/web/make_indexed_page.py">
def make_page(environment, country_1, country_2, the_date):
    '''Create page showing temperature ratios.'''

    data_1 = get_temps(country_1)
    data_2 = get_temps(country_2)
    years = data_1.keys()
    years.sort()

    template = environment.get_template(INDIVIDUAL_PAGE)
    result = template.render(country_1=country_1, data_1=data_1,
                             country_2=country_2, data_2=data_2,
                             years=years, the_date=the_date)

    return result
</pre>

      <p>
        The function that loads existing index data is also pretty simple:
      </p>

<pre src="src/web/make_indexed_page.py">
def load_index(output_dir, filename):
    '''Load index data from output_dir/filename.'''

    path = os.path.join(output_dir, filename)
    reader = open(path, 'r')
    result = json.load(reader)
    reader.close()
    return result
</pre>

      <p>
        All that's left is the function that regenerates the HTML version of the index:
      </p>

<pre src="src/web/make_indexed_page.py">
def make_index(environment, index_data):
    '''Refresh the HTML index page.'''

    template = environment.get_template(INDEX_PAGE)
    return template.render(updated=index_data['updated'],
                           entries=index_data['entries'])
</pre>

      <p class="continue">
        and the HTML template it relies on:
      </p>

<pre src="src/web/index_template.html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Index of Average Annual Temperature Ratios&lt;/title&gt;
    &lt;meta name="revised" content="{{updated}}" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Index of Average Annual Temperature Ratios&lt;/h1&gt;
    &lt;table class="data"&gt;
      {% for entry in entries %}
      &lt;tr&gt;
        &lt;td class="country"&gt;{{entry[0]}}&lt;/td&gt;
        &lt;td class="country"&gt;{{entry[1]}}&lt;/td&gt;
        &lt;td class="revised"&gt;&lt;a href="{{entry[0]}}-{{entry[1]}}.html"&gt;{{entry[2]}}&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
      {% endfor %}
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>
        Notice that the date in each row is actually a hyperlink to the file containing that dataset.
      </p>

      <div class="keypoints" id="k:server">
        <h3>Summary</h3>
        <ul>
          <li>It is hard to make dynamic web applications secure.</li>
          <li>An alternative is to dynamically generate static web pages.</li>
          <li>Every collection of data should provide a machine-readable index.</li>
        </ul>
      </div>

    </section>

    <section id="s:syndicate">

      <h2>Syndicating Data</h2>

      <p>
        To end this chapter,
        we'll use what we have learned to build a simple tool
        to download new temperature comparisons from a web site.
        In broad strokes,
        our program will keep a list of URLs to download data from,
        along with a timestamp showing when data was last downloaded.
        When we run the program,
        it will poll each site to see if any new data sets have been added
        since the last check.
        If any have,
        the program will display their URLs.
      </p>

      <p>
        The first step is to decide how to keep track of what we have downloaded and when.
        The simplest thing is to create another JSON file
        containing the timestamp and the list of URLs.
        We'll call this <code>sources.json</code>:
      </p>

<pre>
{
    "timestamp" : "2013-05-02:07:04:03",
    "sites" : [
        "http://software-carpentry.org/temperatures/index.json",
        "http://some.other.site/some/path/index.json"
    ]
}
</pre>

      <p>
        Each time we run our program,
        it will read this file,
        then download each <code>index.json</code> file.
        If any of those files contain links to data sets that are newer than the timestamp,
        it will print the data set's URL.
        (A real data analysis program would actually download the data
        and do something with it.)
        We will then save a fresh copy of <code>sources.json</code>
        with an updated timestamp.
        Our main program looks like this:
      </p>

<pre src="src/web/syndicate.py">
import date

def main(sources_path):
    '''Check all data sites in list, then update timestamp of sources.json.'''
    old_timestamp, all_sources = read_sources(sources_path)
    new_timestamp = date.datetime.now()
    for source in all_sources:
        for url in get_new_datasets(old_timestamp, source):
            process(url)
    write_sources(sources_path, new_timestamp, sources)
</pre>

      <p>
        That seems pretty simple;
        the only subtlety is that we calculate the new timestamp
        <em>before</em> we start checking for new datasets.
        The reason is that this check might take
        anything from a few seconds to a few hours,
        depending on how busy the Internet is
        and how much data we actually download.
        If we wait until we're done
        and then record that moment as the new timestamp,
        then the next time we run our program,
        we won't download any datasets that were created
        between the time we started the first run of our program
        and the time it finished
        (<a href="#f:when_to_timestamp">Figure XXX</a>).
      </p>

      <figure id="f:when_to_timestamp">
        <img src="img/web/when_to_timestamp.png" alt="When to Create Timestamps"/>
      </figure>

      <p>
        We now have four functions to write:
        <code>read_sources</code>,
        <code>write_sources</code>,
        <code>get_new_datasets</code>,
        and
        <code>process</code>.
        Reading and writing the <code>sources.json</code> file is pretty simple:
      </p>

<pre src="src/web/syndicate.py">
import json

def read_sources(path):
    '''Read timestamp and data sources from JSON files.'''
    reader = open(path, 'r')
    data = json.load(reader)
    timestamp = data['timestamp']
    sources = data['sources']
    return timestamp, sources

def write_sources(sources_path, timestamp, sources):
    '''Write timestamp and data sources to JSON file.'''
    data = {'timestamp' : timestamp,
            'sources'   : sources}
    writer = open(sources_path, 'w')
    json.dump(data, writer)
    writer.close()
</pre>

    <p>
      What about processing a URL?
      Right now,
      we're just going to print it,
      though in a real application we would probably download the data
      and do some further calculations with it:
    </p>

<pre src="src/web/syndicate.py">
def process(url):
    '''Placeholder for processing a data set given its URL.'''
    print url
</pre>

    <p>
      Finally,
      we need to construct a list of dataset URLs
      given the URL of an <code>index.json</code> file:
    </p>

<pre src="src/web/syndicate.py">
import requests

def get_new_datasets(last_checked, index_url):
    '''Return a list of URLs of datasets that are newer than the timestamp.'''
    response = requests.get(index_url)
    index_data = json.loads(index.text)
    result = []
    for (country_a, country_b, updated, dataset_url) in index_data:
        dataset_timestamp = datetime.parse(updated)
        if dataset_timestamp >= last_checked:
            result.append(dataset_url)
    return result
</pre>

      <p>
        <em>This</em> is why we included the full URL for each dataset
        in the <code>index.json</code> file.
        We could use the code that constructs URLs from country codes
        in our syndication program,
        but having the program that generates the data
        store explicit URLs removes the need.
        More importantly,
        it allows people to write client programs in whatever language they want:
        they could use Perl, Ruby, or something that hasn't even been invented yet,
        and not have to translate our URL generator into that language.
      </p>

    </section>

    <section id="s:summary">

      <h2>Summing Up</h2>

      <p>
        The web has changed in many ways over the last 20 years,
        not all of them for the better.
        An HTML page on a modern commercial site
        is likely to include dozens or hundreds of lines of Javascript
        that depend on several large, complicated libraries,
        and which generate the page's content on the fly inside the browser.
        Such a "page" is really a small (or not-so-small) program
        rather than a document in the classical sense of the word,
        and while that may produce a better experience for human users,
        it makes life more difficult for programs
        (and for people with disabilities,
        whose assistive aids are all too easy to confuse).
        And while XML is widely used for representing data,
        many people believe that younger alternatives like JSON
        do a better job of balancing the needs of human and computer readers.
      </p>

      <p>
        Regardless of the technology used,
        though,
        the web's <a href="http://blog.jonudell.net/2011/01/24/seven-ways-to-think-like-the-web/">basic design principles</a>
        are both simple and stable:
        tell people where data is, rather than giving them a copy;
        make the data itself and your names for it
        easy for both human beings and computers to understand;
        remix other people's data,
        and allow them to remix yours.
      </p>

    </section>
<!--
For practicing these things in class (or running tiny sites), the built-in Python servers are useful. In Python 3:

    python -m http.server 80

In Python 2:

    python -m SimpleHTTPServer 80
-->
{% endblock content %}
